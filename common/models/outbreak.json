{
  "name": "outbreak",
  "base": "extendedPersistedModel",
  "idInjection": true,
  "options": {
    "validateUpsert": true
  },
  "scope": {
    "order": [
      "name ASC"
    ]
  },
  "properties": {
    "name": {
      "type": "string",
      "required": true
    },
    "description": {
      "type": "string"
    },
    "disease": {
      "type": "string"
    },
    "countries": {
      "type": [
        "country"
      ]
    },
    "locationIds": [
      "string"
    ],
    "startDate": {
      "type": "date",
      "required": true
    },
    "endDate": {
      "type": "date"
    },
    "longPeriodsBetweenCaseOnset": {
      "type": "number",
      "description": "Number of days used for defining long periods in the dates of onset between cases in the chain of transmission",
      "required": true
    },
    "periodOfFollowup": {
      "type": "number",
      "description": "Duration for the follow-up period in days",
      "required": true
    },
    "frequencyOfFollowUp": {
      "type": "number",
      "required": true,
      "default": 1,
      "description": "Frequency of follow ups in days (once every X days/daily)"
    },
    "frequencyOfFollowUpPerDay": {
      "type": "number",
      "required": true,
      "description": "Number of follow ups to be generated per day"
    },
    "noDaysAmongContacts": {
      "type": "number",
      "required": true,
      "description": "Number of days used to calculate the proportion of new cases detected among known contacts"
    },
    "noDaysInChains": {
      "type": "number",
      "required": true,
      "description": "Number of days used to calculate the proportion of new cases in known transmission chains"
    },
    "noDaysNotSeen": {
      "type": "number",
      "required": true,
      "description": "Number of days used to filter a list of contacts not seen for a specific number of days"
    },
    "noLessContacts": {
      "type": "number",
      "required": true,
      "description": "Number of contacts used to determine the proportion of cases with less than X contacts"
    },
    "noDaysNewContacts": {
      "type": "number",
      "description": "Number of days used to determine if a contact is new",
      "default": 1
    },
    "fieldsToDisplayNode": {
      "type": [
        "string"
      ]
    },
    "caseInvestigationTemplate": {
      "type": [
        "templateQuestion"
      ],
      "default": [],
      "importTopLevelOnly": true
    },
    "contactFollowUpTemplate": {
      "type": [
        "templateQuestion"
      ],
      "default": [],
      "importTopLevelOnly": true
    },
    "labResultsTemplate": {
      "type": [
        "templateQuestion"
      ],
      "default": [],
      "importTopLevelOnly": true
    },
    "caseIdMask": {
      "type": "string",
      "required": true,
      "pattern": "^(?:9*[^9()]*|[^9()]*9*[^9()]*|[^9()]*9*)$",
      "default": "9999999999"
    },
    "contactIdMask": {
      "type": "string",
      "required": true,
      "pattern": "^(?:9*[^9()]*|[^9()]*9*[^9()]*|[^9()]*9*)$",
      "default": "9999999999"
    },
    "arcGisServers": [
      "arcGisServer"
    ],
    "reportingGeographicalLevelId": {
      "type": "string",
      "description": "The maximum geographical level of locations from which reports data is gathered"
    }
  },
  "indexes": {
    "name_index": {
      "name": 1
    },
    "disease_index": {
      "disease": 1
    },
    "startDate_index": {
      "startDate": 1
    }
  },
  "validations": [],
  "relations": {
    "cases": {
      "type": "hasMany",
      "model": "case",
      "foreignKey": "outbreakId"
    },
    "clusters": {
      "type": "hasMany",
      "model": "cluster",
      "foreignKey": "outbreakId"
    },
    "contacts": {
      "type": "hasMany",
      "model": "contact",
      "foreignKey": "outbreakId"
    },
    "events": {
      "type": "hasMany",
      "model": "event",
      "foreignKey": "outbreakId"
    },
    "referenceData": {
      "type": "hasMany",
      "model": "referenceData",
      "foreignKey": "outbreakId"
    },
    "followUps": {
      "type": "hasMany",
      "model": "followUp",
      "foreignKey": "outbreakId"
    },
    "people": {
      "type": "hasMany",
      "model": "person",
      "foreignKey": "outbreakId"
    },
    "labResults": {
      "type": "hasMany",
      "model": "labResult",
      "foreignKey": "outbreakId"
    },
    "attachments": {
      "type": "hasMany",
      "model": "fileAttachment",
      "foreignKey": "outbreakId"
    }
  },
  "acls": [
    {
      "principalType": "ROLE",
      "principalId": "$everyone",
      "permission": "DENY"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "find"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "create"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "patchAttributes"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "findById"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "deleteById"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "count"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "findCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__create__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__findById__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__updateById__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__destroyById__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__count__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "findContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "findContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "__create__contacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "__findById__contacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "__updateById__contacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "__destroyById__contacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "__count__contacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__get__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__create__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__findById__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__updateById__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__destroyById__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__count__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "__get__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_followup",
      "permission": "ALLOW",
      "property": "__create__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "__findById__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_followup",
      "permission": "ALLOW",
      "property": "__updateById__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_followup",
      "permission": "ALLOW",
      "property": "__destroyById__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "__count__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_followup",
      "permission": "ALLOW",
      "property": "restoreContactFollowUp"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findCaseRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "findContactRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findEventRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "createCaseRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "createContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "createEventRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "getCaseRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "getContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "getEventRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "updateCaseRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "updateContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "updateEventRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "deleteCaseRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "deleteContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "deleteEventRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCaseRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "filteredCountCaseRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "filteredCountContactRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countEventRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "filteredCountEventRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "convertContactToCase"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "convertCaseToContact"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "getLocationsHierarchicalList"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "restoreCase"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "restoreContact"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "restoreEvent"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__get__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "__get__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__create__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__findById__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__updateById__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__destroyById__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__count__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "getReferenceData"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "__create__referenceData"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "__findById__referenceData"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "__updateById__referenceData"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "__destroyById__referenceData"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "generateCaseVisualId"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "generateContactVisualId"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "getCaseQRResourceLink"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "getContactQRResourceLink"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "getEventQRResourceLink"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "__get__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "__findById__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "__create__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "__updateById__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "__destroyById__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "__count__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__get__clusters__relationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "__get__clusters__relationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__count__clusters__relationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "__count__clusters__relationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "countNewContactsByExposure"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countNewContactsByExposure"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_followup",
      "permission": "ALLOW",
      "property": "generateFollowups"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "filteredCountCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "filteredCountCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "filteredCountContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "filteredCountContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "filteredCountEvents"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "filteredCountEvents"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countIndependentTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "getIndependentTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "findFollowUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "__findById__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "__count__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactsSeen"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactsLostToFollowup"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countNewCasesInKnownTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countNewCasesOutsideKnownTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCasesWithLessThanXContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countEventNewContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "longPeriodsBetweenDatesOfOnsetInTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "buildNewChainsFromRegisteredContactsWhoBecameCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countNewChainsFromRegisteredContactsWhoBecameCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countCasesContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countCasesContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCasesContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "findSecondaryCasesWithDateOfOnsetBeforePrimaryCase"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countFollowUpContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countNewCasesInThePreviousXDaysDetectedAmongKnownContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countNewCasesInThePreviousXDaysDetectedAmongKnownContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactsNotSeenInXDays"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countContactsNotSeenInXDays"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactsWithSuccessfulFollowups"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_team",
      "permission": "ALLOW",
      "property": "countContactsWithSuccessfulFollowups"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countContactsWithSuccessfulFollowups"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countFollowUpsPerTeamPerDay"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_team",
      "permission": "ALLOW",
      "property": "countFollowUpsPerTeamPerDay"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "mergePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "mergePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "exportFilteredCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "exportFilteredRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "exportFilteredRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "countCasesPerPeriod"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "listLatestFollowUpsForContactsIfNotPerformed"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "filteredCountLatestFollowUpsForContactsIfNotPerformed"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__get__people"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "__get__people"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__count__people"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "__count__people"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "listInconsistenciesInKeyDates"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "listInconsistenciesInKeyDates"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "restoreReferenceData"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "importableFileUpload"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "getImportableFileJsonById"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "importImportableLabResultsFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "exportCaseInvestigationTemplate"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "contactDossier"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_report",
      "permission": "ALLOW",
      "property": "caseDossier"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "contactDossier"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "caseDossier"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "importImportableCasesFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "importImportableContactsFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactsPerLocation"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "exportFilteredContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "exportFilteredContactFollowUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "exportFilteredReferenceData"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "importImportableReferenceDataFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findPeopleInCluster"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "findPeopleInCluster"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countPeopleInCluster"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countPeopleInCluster"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "filteredCountFollowUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "exportFilteredFollowups"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "exportExistingEmptyCaseInvestigation"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findPossiblePersonDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countPossiblePersonDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "createCaseMultipleContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "createEventMultipleContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findLabResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__count__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "filteredCountLabResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_outbreak",
      "permission": "ALLOW",
      "property": "restoreOutbreak"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findCaseRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCaseRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findCaseRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCaseRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "findContactRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "findContactRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findEventRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countEventRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "findEventRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countEventRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCasesPerClassification"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactsPerRiskLevel"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCasesStratifiedByClassificationOverTime"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCasesStratifiedByOutcomeOverTime"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCasesStratifiedByClassificationOverReportingTime"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countFollowUpsByTeam"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "__findById__attachments"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "__findById__attachments"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "attachmentUpload"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "attachmentUpload"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "attachmentDownload"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "attachmentDownload"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "__destroyById__attachments"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "__destroyById__attachments"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "bulkCreateRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "bulkCreateRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "downloadCaseClassificationPerLocationLevelReport"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "countCasesPerLocationLevel"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "downloadContactTracingPerLocationLevelReport"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "countContactsPerLocationLevel"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "getCaseMovement"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "getContactMovement"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "caseDelayBetweenOnsetAndLabTesting"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "exportContactFollowUpListPerDay"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_case",
      "permission": "ALLOW",
      "property": "restoreLabResult"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "exportDailyContactFollowUpList"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "exportRangeListOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "filteredCountContactsOnFollowUpList"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_contact",
      "permission": "ALLOW",
      "property": "getContactPossibleDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "getCasePossibleDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_case",
      "permission": "ALLOW",
      "property": "caseDelayBetweenOnsetAndHospitalizationIsolation"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_outbreak",
      "permission": "ALLOW",
      "property": "getContactFollowUpReport"
    },
    {
      "principalType": "ROLE",
      "principalId": "write_contact",
      "permission": "ALLOW",
      "property": "modifyCaseMultipleContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "getFollowUpsGroupedByContact"
    },
    {
      "principalType": "ROLE",
      "principalId": "read_followup",
      "permission": "ALLOW",
      "property": "countFollowUpsGroupedByContact"
    }
  ],
  "methods": {
    "prototype.findCaseRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "Relationships of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationships of case.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships"
      }
    },
    "prototype.createCaseRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Created Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates a new instance in relationships of this model.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/relationships"
      }
    },
    "prototype.getCaseRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Relationship of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Find a related item by id for relationships.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/:fk"
      }
    },
    "prototype.updateCaseRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for case"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Updated Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Update a related item by id for relationships.",
      "http": {
        "verb": "put",
        "path": "/cases/:nk/relationships/:fk"
      }
    },
    "prototype.deleteCaseRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for case"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "object",
          "root": true,
          "required": true
        }
      ],
      "description": "Delete a related item by id for relationships.",
      "http": {
        "verb": "del",
        "path": "/cases/:nk/relationships/:fk"
      }
    },
    "prototype.countCaseRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships of a case",
          "required": true
        }
      ],
      "description": "Counts relationships of case.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/count"
      }
    },
    "prototype.findContactRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "Relationships of a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationships of contacts.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships"
      }
    },
    "prototype.createContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Created Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates a new instance in relationships of this model.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/relationships"
      }
    },
    "prototype.getContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Relationship of a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Find a related item by id for relationships.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/:fk"
      }
    },
    "prototype.updateContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Updated Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Update a related item by id for relationships.",
      "http": {
        "verb": "put",
        "path": "/contacts/:nk/relationships/:fk"
      }
    },
    "prototype.deleteContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "object",
          "root": true,
          "required": true
        }
      ],
      "description": "Delete a related item by id for relationships.",
      "http": {
        "verb": "del",
        "path": "/contacts/:nk/relationships/:fk"
      }
    },
    "prototype.countContactRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships of a contact",
          "required": true
        }
      ],
      "description": "Counts relationships of contact.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/count"
      }
    },
    "prototype.findEventRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "Relationships of a event",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationships of event.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships"
      }
    },
    "prototype.createEventRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Created Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates a new instance in relationships of this model.",
      "http": {
        "verb": "post",
        "path": "/events/:nk/relationships"
      }
    },
    "prototype.getEventRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Relationship of a event",
          "root": true,
          "required": true
        }
      ],
      "description": "Find a related item by id for relationships.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/:fk"
      }
    },
    "prototype.updateEventRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for event"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Updated Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Update a related item by id for relationships.",
      "http": {
        "verb": "put",
        "path": "/events/:nk/relationships/:fk"
      }
    },
    "prototype.deleteEventRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for event"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "object",
          "root": true,
          "required": true
        }
      ],
      "description": "Delete a related item by id for relationships.",
      "http": {
        "verb": "del",
        "path": "/events/:nk/relationships/:fk"
      }
    },
    "prototype.countEventRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships of a event",
          "required": true
        }
      ],
      "description": "Counts relationships of event.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/count"
      }
    },
    "prototype.convertContactToCase": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "body",
          "type": "case",
          "http": {
            "source": "body"
          },
          "description": "Case specific properties"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "case",
          "type": "case",
          "description": "Case resulted from the conversion",
          "required": true,
          "root": true
        }
      ],
      "description": "Converts contact to case.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/convert-to-case"
      }
    },
    "prototype.convertCaseToContact": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "contact",
          "type": "contact",
          "description": "Contact resulted from the conversion",
          "required": true,
          "root": true
        }
      ],
      "description": "Converts case to contact.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/convert-to-contact"
      }
    },
    "prototype.getLocationsHierarchicalList": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'includeChildren' boolean on the first level in 'where'; this flag is taken into consideration only if other filters are applied"
        }
      ],
      "returns": [
        {
          "arg": "locations",
          "type": [
            {
              "type": {
                "location": "location",
                "children": [
                  {
                    "type": {
                      "location": "location",
                      "children": []
                    }
                  }
                ]
              }
            }
          ],
          "root": true,
          "required": true
        }
      ],
      "description": "Get hierarchical list of locations for an outbreak.",
      "http": {
        "verb": "get",
        "path": "/locations/hierarchical"
      }
    },
    "prototype.restoreCase": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "case",
          "type": "case",
          "description": "Case",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted case.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/restore"
      }
    },
    "prototype.restoreContact": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "contact",
          "type": "contact",
          "description": "Contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted contact.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/restore"
      }
    },
    "prototype.restoreEvent": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "event",
          "type": "event",
          "description": "Event",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted event.",
      "http": {
        "verb": "post",
        "path": "/events/:nk/restore"
      }
    },
    "prototype.getReferenceData": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "referenceData",
          "type": [
            "referenceData"
          ],
          "description": "System and outbreak specific reference data",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries system and outbreak specific reference data list.",
      "http": {
        "verb": "get",
        "path": "/reference-data"
      }
    },
    "prototype.generateCaseVisualId": {
      "accepts": [
        {
          "arg": "visualIdMask",
          "type": "string",
          "required": true,
          "description": "Visual ID mask partially resolved (except for the sequence no.)"
        },
        {
          "arg": "personId",
          "type": "string",
          "description": "Case ID for validating existing visual ID (optional)"
        }
      ],
      "returns": [
        {
          "arg": "visualId",
          "type": "string",
          "description": "Visual ID",
          "root": true,
          "required": true
        }
      ],
      "description": "Generates the next (available) visual ID based on the outbreak mask.",
      "http": {
        "verb": "post",
        "path": "/cases/generate-visual-id"
      }
    },
    "prototype.generateContactVisualId": {
      "accepts": [
        {
          "arg": "visualIdMask",
          "type": "string",
          "required": true,
          "description": "Visual ID mask partially resolved (except for the sequence no.)"
        },
        {
          "arg": "personId",
          "type": "string",
          "description": "Contact ID for validating existing visual ID (optional)"
        }
      ],
      "returns": [
        {
          "arg": "visualId",
          "type": "string",
          "description": "Visual ID",
          "root": true,
          "required": true
        }
      ],
      "description": "Generates the next (available) visual ID based on the outbreak mask.",
      "http": {
        "verb": "post",
        "path": "/contacts/generate-visual-id"
      }
    },
    "prototype.getCaseQRResourceLink": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Get a resource link embedded in a QR Code Image (png) for a case.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/qr-resource-link"
      }
    },
    "prototype.getContactQRResourceLink": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Get a resource link embedded in a QR Code Image (png) for a contact.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/qr-resource-link"
      }
    },
    "prototype.getEventQRResourceLink": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Get a resource link embedded in a QR Code Image (png) for a event.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/qr-resource-link"
      }
    },
    "prototype.countNewContactsByExposure": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noDaysNewContacts' number on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "newContactsCount": "number",
            "exposureType": {
              "type": {
                "id": {
                  "type": "string",
                  "description": "Exposure type ID"
                },
                "count": {
                  "type": "number",
                  "description": "Contacts number for exposure type"
                },
                "contactIDs": {
                  "type": [
                    "string"
                  ],
                  "description": "Contact IDs container"
                }
              }
            }
          },
          "description": "Object containing new contacts counters for each found exposure type",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the new contacts and groups them by exposure type",
      "http": {
        "verb": "get",
        "path": "/contacts/new-by-exposure-type/count"
      }
    },
    "prototype.filteredCountContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case', 'where.followUp' MongoDB compatible queries"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of contacts that pass the filter",
          "required": true
        }
      ],
      "description": "Counts the contacts of an outbreak",
      "http": [
        {
          "verb": "get",
          "path": "/contacts/filtered-count"
        },
        {
          "verb": "post",
          "path": "/contacts/filtered-count"
        }
      ]
    },
    "prototype.filteredCountEvents": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: this request also accepts a `noRelationships` flag on the first level of `where`."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of events that pass the filter",
          "required": true
        }
      ],
      "description": "Counts the cases that pass a filter (which can now accept relations)",
      "http": {
        "verb": "get",
        "path": "/events/filtered-count"
      }
    },
    "prototype.exportFilteredCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "xml",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, xml, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export filtered list of cases",
      "http": {
        "verb": "get",
        "path": "/cases/export"
      }
    },
    "prototype.exportFilteredRelationships": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Supports 'where.person' & 'where.followUp' MongoDB compatible queries. If you include both person & followUp conditions, then and AND will be applied between them."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "xml",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, xml, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export filtered list of relationships",
      "http": {
        "verb": "get",
        "path": "/relationships/export"
      }
    },
    "prototype.restoreContactFollowUp": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for followUps"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "followUp",
          "type": [
            "followUp"
          ],
          "description": "Follow Up",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted follow-up.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/follow-ups/:fk/restore"
      }
    },
    "prototype.generateFollowups": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "generateFollowup",
          "description": "Follow up required period start/end dates and targeted optional flag.",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "response",
          "type": {
            "count": {
              "type": "number"
            }
          },
          "description": "Number of generated follow ups",
          "root": true,
          "required": true
        }
      ],
      "description": "Generate a list of follow-ups",
      "http": {
        "verb": "post",
        "path": "/generate-followups"
      }
    },
    "prototype.countIndependentTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). This accepts a 'where.person', 'where.chainIncludesPerson', 'where.endDate' (used to provide a snapshot of chains until the specified end date), where.includeContacts (default false) queries."
        }
      ],
      "returns": [
        {
          "arg": "chains",
          "type": {
            "chains": [
              {
                "type": {
                  "length": {
                    "type": "number",
                    "description": "Number of chain links"
                  },
                  "size": {
                    "type": "number",
                    "description": "Number of chain nodes"
                  },
                  "active": "boolean"
                }
              }
            ],
            "length": "number",
            "activeChainsCount": "number",
            "isolatedNodesCount": "number"
          },
          "description": "Number of transmission chains and the length of each chain",
          "required": true,
          "root": true
        }
      ],
      "description": "Count the number of independent transmission chains",
      "http": {
        "verb": "get",
        "path": "/relationships/independent-transmission-chains/filtered-count"
      }
    },
    "prototype.getIndependentTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'where.active' boolean, 'where.size' number, 'where.person', 'where.chainIncludesPerson', 'where.endDate' (used to provide a snapshot of chains until the specified end date), where.includeContacts (default false) queries."
        }
      ],
      "returns": [
        {
          "arg": "chains",
          "type": {
            "nodes": {
              "type": {
                "<personId>": {
                  "type": "person"
                }
              }
            },
            "edges": {
              "type": {
                "<relationshipId>": {
                  "type": "relationship"
                }
              }
            },
            "transmissionChains": {
              "type": {
                "chains": [
                  {
                    "type": {
                      "chain": [
                        "string"
                      ],
                      "period": {
                        "type": {
                          "startDate": "date",
                          "endDate": "date",
                          "duration": {
                            "type": "number",
                            "description": "Transmission chain duration in days"
                          }
                        }
                      },
                      "active": "boolean"
                    }
                  }
                ],
                "length": {
                  "type": "number",
                  "description": "Number of chain links"
                },
                "size": {
                  "type": "number",
                  "description": "Number of chain nodes"
                }
              }
            }
          },
          "description": "Independent transmission chains",
          "required": true,
          "root": true
        }
      ],
      "description": "Get independent transmission chains",
      "http": {
        "verb": "get",
        "path": "/relationships/independent-transmission-chains"
      }
    },
    "prototype.countContactsSeen": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "contactsSeenCount": "number",
            "contactIDs": {
              "type": [
                "string"
              ],
              "description": "Array with IDs of contacts that are seen",
              "required": true
            },
            "teams": [
              {
                "type": {
                  "id": "string",
                  "contactsSeenCount": "number",
                  "contactIDs": {
                    "type": [
                      "string"
                    ],
                    "description": "Array with IDs of contacts that are seen",
                    "required": true
                  }
                }
              }
            ]
          },
          "description": "Object containing counters for seen contacts",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of seen contacts as well as per team",
      "http": {
        "verb": "get",
        "path": "/follow-ups/contacts-seen/count"
      }
    },
    "prototype.countContactsLostToFollowup": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "contactsLostToFollowupCount": "number",
            "contactIDs": {
              "type": [
                "string"
              ],
              "description": "Array with IDs of contacts that are lost to follow-up",
              "required": true
            },
            "teams": [
              {
                "type": {
                  "id": "string",
                  "contactsLostToFollowupCount": "number",
                  "contactIDs": {
                    "type": [
                      "string"
                    ],
                    "description": "Array with IDs of contacts that are lost to follow-up",
                    "required": true
                  }
                }
              }
            ]
          },
          "description": "Object containing counters for contacts lost to follow-up",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of contacts lost to follow-up as well as per team",
      "http": {
        "verb": "get",
        "path": "/follow-ups/contacts-lost-to-follow-up/count"
      }
    },
    "prototype.countCasesWithLessThanXContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noLessContacts' number on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "casesCount": {
              "type": "number",
              "description": "Number of cases with less than X contacts",
              "required": true
            },
            "caseIDs": {
              "type": [
                "string"
              ],
              "description": "Array with IDs of cases with less than X contacts",
              "required": true
            },
            "cases": [
              {
                "type": {
                  "id": "string",
                  "contactsCount": {
                    "type": "number",
                    "description": "Number of contacts for case",
                    "required": true
                  },
                  "contactIDs": [
                    "string"
                  ]
                },
                "description": "Array with information for the cases with less than X contacts"
              }
            ]
          },
          "required": true,
          "root": true
        }
      ],
      "description": "Count the number of cases with less than X contacts; Also return the case IDs",
      "http": {
        "verb": "get",
        "path": "/relationships/cases-with-less-than-x-contacts/count"
      }
    },
    "prototype.countNewCasesInKnownTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noDaysInChains' number on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "newCases": "number",
            "total": "number",
            "caseIds": [
              "string"
            ]
          },
          "description": "Retrieve number of new cases in known transmission chains",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of new cases vs total number of cases in known transmission chains",
      "http": {
        "verb": "get",
        "path": "/relationships/new-cases-in-transmission-chains/count"
      }
    },
    "prototype.countNewCasesOutsideKnownTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noDaysInChains' number on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "newCases": "number",
            "total": "number",
            "caseIds": [
              "string"
            ]
          },
          "description": "Retrieve number of new cases outside known transmission chains",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of new cases vs total number of cases outside known transmission chains",
      "http": {
        "verb": "get",
        "path": "/relationships/new-cases-outside-transmission-chains/count"
      }
    },
    "prototype.countEventNewContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noDaysNewContacts' number on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "newContactsCount": "number",
            "events": [
              {
                "type": {
                  "id": "string",
                  "newContactsCount": "number",
                  "contactIDs": [
                    "string"
                  ]
                }
              }
            ]
          },
          "description": "Object containing counters for new contacts for each event",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of new contacts for each event",
      "http": {
        "verb": "get",
        "path": "/relationships/events-new-contacts/count"
      }
    },
    "prototype.longPeriodsBetweenDatesOfOnsetInTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "List of relationships that links cases with long periods between the dates of onset (includes people relation and the time difference in differenceBetweenDatesOfOnset param)",
          "root": true,
          "required": true
        }
      ],
      "description": "Get a list of relationships that links cases with long periods between the dates of onset",
      "http": {
        "verb": "get",
        "path": "/relationships/long-periods-between-dates-of-onset-in-transmission-chains"
      }
    },
    "prototype.buildNewChainsFromRegisteredContactsWhoBecameCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "chains",
          "type": {
            "nodes": {
              "type": {
                "<personId>": {
                  "type": "person"
                }
              }
            },
            "edges": {
              "type": {
                "<relationshipId>": {
                  "type": "relationship"
                }
              }
            },
            "transmissionChains": {
              "type": {
                "chains": [
                  {
                    "type": {
                      "chain": [
                        "string"
                      ],
                      "period": {
                        "type": {
                          "startDate": "date",
                          "endDate": "date",
                          "duration": {
                            "type": "number",
                            "description": "Transmission chain duration in days"
                          }
                        }
                      },
                      "active": "boolean"
                    }
                  }
                ],
                "length": "number"
              }
            }
          },
          "description": "New transmission chains",
          "required": true,
          "root": true
        }
      ],
      "description": "Build new transmission chains from registered contacts who became cases",
      "http": {
        "verb": "get",
        "path": "/relationships/new-transmission-chains-from-registered-contacts-who-became-cases"
      }
    },
    "prototype.countNewChainsFromRegisteredContactsWhoBecameCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "chains",
          "type": {
            "chains": [
              {
                "type": {
                  "length": "number",
                  "active": "boolean"
                }
              }
            ],
            "length": "number",
            "activeChainsCount": "number",
            "isolatedNodesCount": "number"
          },
          "description": "Number of transmission chains and the length of each chain",
          "required": true,
          "root": true
        }
      ],
      "description": "Count new transmission chains from registered contacts who became cases",
      "http": {
        "verb": "get",
        "path": "/relationships/new-transmission-chains-from-registered-contacts-who-became-cases/filtered-count"
      }
    },
    "prototype.countCasesContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "casesCount": {
              "type": "number",
              "description": "Total number of cases",
              "required": true
            },
            "contactsCount": {
              "type": "number",
              "description": "Total number of contacts related to cases; Note there might be other contacts related to events.",
              "required": true
            },
            "meanNoContactsPerCase": {
              "type": "number",
              "description": "Mean Number of contacts per case",
              "required": true
            },
            "medianNoContactsPerCase": {
              "type": "number",
              "description": "Median Number of contacts per case",
              "required": true
            },
            "cases": [
              {
                "type": {
                  "id": "string",
                  "contactsCount": {
                    "type": "number",
                    "description": "Number of contacts for case",
                    "required": true
                  },
                  "contactIDs": [
                    "string"
                  ]
                }
              }
            ]
          },
          "description": "Object containing counters for contacts per case",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of contacts for each case; Additionally calculate mean/median",
      "http": {
        "verb": "get",
        "path": "/relationships/contacts-per-case/count"
      }
    },
    "prototype.findSecondaryCasesWithDateOfOnsetBeforePrimaryCase": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "results",
          "type": [
            {
              "type": {
                "primaryCase": "case",
                "secondaryCase": "case",
                "relationship": "relationship"
              }
            }
          ],
          "description": "List of secondary cases that have date of onset before the date of onset of primary cases",
          "root": true,
          "required": true
        }
      ],
      "description": "Get a list of secondary cases that have date of onset before the date of onset of primary cases",
      "http": {
        "verb": "get",
        "path": "/relationships/secondary-cases-with-date-of-onset-before-primary-case"
      }
    },
    "prototype.countFollowUpContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Accepts 'date' on the first level of 'where' property"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "contactsCount": {
              "type": "number",
              "description": "Number of contacts on follow-up list",
              "required": true
            },
            "followUpsCount": {
              "type": "number",
              "description": "Total number of follow-ups.",
              "required": true
            },
            "contactIDs": [
              "string"
            ]
          },
          "description": "Object containing counters for contacts on follow-up list",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of contacts on follow-up list on a specific day (default day: today)",
      "http": {
        "verb": "get",
        "path": "/follow-ups/contacts/count"
      }
    },
    "prototype.countNewCasesInThePreviousXDaysDetectedAmongKnownContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noDaysAmongContacts' number on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "newCasesCount": {
              "type": "number",
              "description": "Number of new cases in the previous X days",
              "required": true
            },
            "newCasesAmongKnownContactsCount": {
              "type": "number",
              "description": "Number of new cases in the previous X days detected among known contacts",
              "required": true
            },
            "newCasesAmongKnownContactsIDs": [
              "string"
            ]
          },
          "description": "Object containing counters for new cases in the previous X days",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of new cases in the previous X days",
      "http": {
        "verb": "get",
        "path": "/cases/new-among-known-contacts/count"
      }
    },
    "prototype.countContactsNotSeenInXDays": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noDaysNotSeen' number on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "contactsCount": {
              "type": "number",
              "description": "Number of contacts not seen in the past X days",
              "required": true
            },
            "contactIDs": [
              "string"
            ]
          },
          "description": "Object containing counters for contacts not seen in the past X days",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of contacts not seen in the past X days",
      "http": {
        "verb": "get",
        "path": "/follow-ups/contacts-not-seen/count"
      }
    },
    "prototype.countContactsWithSuccessfulFollowups": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "totalContactsWithFollowupsCount": "number",
            "contactsWithSuccessfulFollowupsCount": "number",
            "teams": {
              "type": [
                {
                  "type": {
                    "id": "string",
                    "totalContactsWithFollowupsCount": "number",
                    "contactsWithSuccessfulFollowupsCount": "number",
                    "followedUpContactsIDs": [
                      "string"
                    ],
                    "missedContactsIDs": [
                      "string"
                    ]
                  }
                }
              ]
            },
            "contacts": {
              "type": [
                {
                  "type": {
                    "id": "string",
                    "totalFollowupsCount": "number",
                    "successfulFollowupsCount": "number"
                  }
                }
              ]
            }
          },
          "description": "Object containing counters for contacts with follow-ups and contacts with successful follow-ups",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of contacts with follow-ups and contacts with successful follow-ups",
      "http": {
        "verb": "get",
        "path": "/follow-ups/contacts-with-successful-follow-ups/count"
      }
    },
    "prototype.countFollowUpsPerTeamPerDay": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "totalFollowupsCount": "number",
            "successfulFollowupsCount": "number",
            "teams": {
              "type": [
                {
                  "type": {
                    "id": "string",
                    "dates": {
                      "type": [
                        {
                          "type": {
                            "date": "date",
                            "totalFollowupsCount": "number",
                            "successfulFollowupsCount": "number",
                            "contactsIDs": [
                              "string"
                            ]
                          }
                        }
                      ]
                    }
                  }
                }
              ]
            }
          },
          "description": "Object containing counters for follow-ups per day",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of followups and successful followups",
      "http": {
        "verb": "get",
        "path": "/follow-ups/per-team-per-day/count"
      }
    },
    "prototype.mergePeople": {
      "accepts": [
        {
          "arg": "data",
          "model": "mergePeopleProps",
          "type": "object",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "model",
          "type": "object",
          "description": "Case/Contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Merge multiple people of the same type (case/event/contact)",
      "http": {
        "verb": "post",
        "path": "/merge"
      }
    },
    "prototype.countCasesPerPeriod": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'periodType': enum [day, week, month], 'periodInterval': ['date', 'date'], 'includeTotals': boolean (if false 'total' response properties are not calculated), 'includeDeaths': boolean (if false 'death' response properties are not calculated) on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "totalCasesCount": {
              "type": "number",
              "description": "Total number of alive cases in the Outbreak. Present only if 'includeTotals' filter is sent as true"
            },
            "totalDeadCasesCount": {
              "type": "number",
              "description": "Total number of dead cases in the Outbreak. Present only if 'includeTotals' and 'includeDeaths' filters are sent as true"
            },
            "totalDeadConfirmedCasesCount": {
              "type": "number",
              "description": "Total number of dead confirmed cases in the Outbreak. Present only if 'includeTotals' and 'includeDeaths' filters are sent as true"
            },
            "totalCasesClassificationCounters": {
              "type": {
                "{caseClassification}": {
                  "type": {
                    "count": "number",
                    "caseIDs": [
                      "string"
                    ],
                    "locations": {
                      "type": [
                        {
                          "type": {
                            "id": "string",
                            "totalCasesCount": {
                              "type": "number",
                              "description": "Total number of alive cases with the classification in the Outbreak at the location"
                            },
                            "caseIDs": {
                              "type": [
                                "string"
                              ],
                              "description": "Array containing the IDs of alive cases with the classification in the Outbreak at the location"
                            }
                          }
                        }
                      ],
                      "description": "Object containing counters for cases with the classification per location"
                    }
                  }
                }
              },
              "description": "Total number of cases per classification in the Outbreak. Present only if 'includeTotals' filters are sent as true"
            },
            "totalCasesCountersPerLocation": {
              "type": {
                "locations": {
                  "type": [
                    {
                      "type": {
                        "id": "string",
                        "totalCasesCount": {
                          "type": "number",
                          "description": "Total number of alive cases in the Outbreak at the location"
                        },
                        "totalDeadCasesCount": {
                          "type": "number",
                          "description": "Total number of dead cases in the Outbreak at the location. Present only if 'includeDeaths' filter is sent as true"
                        },
                        "totalDeadConfirmedCasesCount": {
                          "type": "number",
                          "description": "Total number of dead confirmed cases in the Outbreak at the location. Present only if 'includeDeaths' filter is sent as true"
                        },
                        "caseIDs": {
                          "type": [
                            "string"
                          ],
                          "description": "Array containing the alive cases IDs in the Outbreak at the location"
                        },
                        "deadCaseIDs": {
                          "type": [
                            "string"
                          ],
                          "description": "Array containing the dead cases IDs in the Outbreak at the location. Present only if 'includeDeaths' filter is sent as true"
                        },
                        "deadConfirmedCaseIDs": {
                          "type": [
                            "string"
                          ],
                          "description": "Array containing the dead confirmed cases IDs in the Outbreak at the location. Present only if 'includeDeaths' filter is sent as true"
                        }
                      }
                    }
                  ],
                  "description": "Object containing counters for cases per location"
                }
              },
              "description": "Total number of cases per classification in the Outbreak in the provided interval (if no interval is provided the current day will be used)"
            },
            "caseIDs": {
              "type": [
                "string"
              ],
              "description": "Array containing the alive cases IDs in the Outbreak. Present only if 'includeTotals' filters are sent as true"
            },
            "deadCaseIDs": {
              "type": [
                "string"
              ],
              "description": "Array containing the dead cases IDs in the Outbreak. Present only if 'includeTotals' and 'includeDeaths' filters are sent as true"
            },
            "deadConfirmedCaseIDs": {
              "type": [
                "string"
              ],
              "description": "Array containing the dead confirmed cases IDs in the Outbreak. Present only if 'includeTotals' and 'includeDeaths' filters are sent as true"
            },
            "totalCasesForIntervalCount": {
              "type": "number",
              "description": "Total number of alive cases in the Outbreak for the interval provided (if no interval is provided the current day will be used)"
            },
            "totalDeadCasesForIntervalCount": {
              "type": "number",
              "description": "Total number of dead cases in the Outbreak for the interval provided (if no interval is provided the current day will be used). Present only if 'includeDeaths' filter is sent as true"
            },
            "totalDeadConfirmedCasesForIntervalCount": {
              "type": "number",
              "description": "Total number of dead confirmed cases in the Outbreak for the interval provided (if no interval is provided the current day will be used). Present only if 'includeDeaths' filter is sent as true"
            },
            "totalCasesClassificationCountersForInterval": {
              "type": {
                "{caseClassification}": {
                  "type": {
                    "count": "number",
                    "caseIDs": [
                      "string"
                    ],
                    "locations": {
                      "type": [
                        {
                          "type": {
                            "id": "string",
                            "totalCasesCount": {
                              "type": "number",
                              "description": "Total number of alive cases with the classification in the Outbreak for the interval provided at the location"
                            },
                            "caseIDs": {
                              "type": [
                                "string"
                              ],
                              "description": "Array containing the IDs of alive cases with the classification in the Outbreak in the provided interval at the location"
                            }
                          }
                        }
                      ],
                      "description": "Object containing counters for cases with the classification per location"
                    }
                  }
                }
              },
              "description": "Total number of cases per classification in the Outbreak in the provided interval (if no interval is provided the current day will be used)"
            },
            "totalCasesCountersForIntervalPerLocation": {
              "type": {
                "locations": {
                  "type": [
                    {
                      "type": {
                        "id": "string",
                        "totalCasesCount": {
                          "type": "number",
                          "description": "Total number of alive cases in the Outbreak for the interval provided at the location"
                        },
                        "totalDeadCasesCount": {
                          "type": "number",
                          "description": "Total number of dead cases in the Outbreak for the interval provided at the location. Present only if 'includeDeaths' filter is sent as true"
                        },
                        "totalDeadConfirmedCasesCount": {
                          "type": "number",
                          "description": "Total number of dead confirmed cases in the Outbreak for the interval provided at the location. Present only if 'includeDeaths' filter is sent as true"
                        },
                        "caseIDs": {
                          "type": [
                            "string"
                          ],
                          "description": "Array containing the alive cases IDs in the Outbreak in the provided interval at the location"
                        },
                        "deadCaseIDs": {
                          "type": [
                            "string"
                          ],
                          "description": "Array containing the dead cases IDs in the Outbreak in the provided interval at the location. Present only if 'includeDeaths' filter is sent as true"
                        },
                        "deadConfirmedCaseIDs": {
                          "type": [
                            "string"
                          ],
                          "description": "Array containing the dead confirmed cases IDs in the Outbreak in the provided interval at the location. Present only if 'includeDeaths' filter is sent as true"
                        }
                      }
                    }
                  ],
                  "description": "Object containing counters for cases per location"
                }
              },
              "description": "Total number of cases per classification in the Outbreak in the provided interval (if no interval is provided the current day will be used)"
            },
            "caseIDsForInterval": {
              "type": [
                "string"
              ],
              "description": "Array containing the alive cases IDs in the Outbreak in the provided interval (if no interval is provided the current day will be used)"
            },
            "deadCaseIDsForInterval": {
              "type": [
                "string"
              ],
              "description": "Array containing the dead cases IDs in the Outbreak in the provided interval. Present only if 'includeDeaths' filter is sent as true"
            },
            "deadConfirmedCaseIDsForInterval": {
              "type": [
                "string"
              ],
              "description": "Array containing the dead confirmed cases IDs in the Outbreak in the provided interval. Present only if 'includeDeaths' filter is sent as true"
            },
            "period": {
              "type": [
                {
                  "type": {
                    "start": "date",
                    "end": "date",
                    "totalCasesCount": {
                      "type": "number",
                      "description": "Total number of alive cases in the Outbreak for the period"
                    },
                    "totalDeadCasesCount": {
                      "type": "number",
                      "description": "Total number of dead cases in the Outbreak for the period. Present only if and 'includeDeaths' filter is sent as true"
                    },
                    "totalDeadConfirmedCasesCount": {
                      "type": "number",
                      "description": "Total number of dead confirmed cases in the Outbreak for the period. Present only if 'includeDeaths' filter is sent as true"
                    },
                    "classificationCounters": {
                      "type": {
                        "{caseClassification}": {
                          "type": {
                            "count": "number",
                            "caseIDs": [
                              "string"
                            ],
                            "locations": {
                              "type": [
                                {
                                  "type": {
                                    "id": "string",
                                    "totalCasesCount": {
                                      "type": "number",
                                      "description": "Total number of alive cases with the classification in the Outbreak for the period at the location"
                                    },
                                    "caseIDs": {
                                      "type": [
                                        "string"
                                      ],
                                      "description": "Array containing the IDs of alive cases with the classification in the Outbreak for the period at the location"
                                    }
                                  }
                                }
                              ],
                              "description": "Object containing counters for cases with the classification per location"
                            }
                          }
                        }
                      }
                    },
                    "countersPerLocation": {
                      "type": {
                        "locations": {
                          "type": [
                            {
                              "type": {
                                "id": "string",
                                "totalCasesCount": {
                                  "type": "number",
                                  "description": "Total number of alive cases in the Outbreak for the period at the location"
                                },
                                "totalDeadCasesCount": {
                                  "type": "number",
                                  "description": "Total number of dead cases in the Outbreak for the period at the location. Present only if 'includeDeaths' filter is sent as true"
                                },
                                "totalDeadConfirmedCasesCount": {
                                  "type": "number",
                                  "description": "Total number of dead confirmed cases in the Outbreak for the period at the location. Present only if 'includeDeaths' filter is sent as true"
                                },
                                "caseIDs": {
                                  "type": [
                                    "string"
                                  ],
                                  "description": "Array containing the alive cases IDs in the Outbreak for the period at the location"
                                },
                                "deadCaseIDs": {
                                  "type": [
                                    "string"
                                  ],
                                  "description": "Array containing the dead cases IDs in the Outbreak for the period  at the location. Present only if 'includeDeaths' filter is sent as true"
                                },
                                "deadConfirmedCaseIDs": {
                                  "type": [
                                    "string"
                                  ],
                                  "description": "Array containing the dead confirmed cases IDs in the Outbreak for the period at the location. Present only if 'includeDeaths' filter is sent as true"
                                }
                              }
                            }
                          ],
                          "description": "Object containing counters for cases per location"
                        }
                      },
                      "description": "Total number of cases per classification in the Outbreak in the provided interval (if no interval is provided the current day will be used)"
                    },
                    "caseIDs": {
                      "type": [
                        "string"
                      ],
                      "description": "Array containing the alive cases IDs in the Outbreak for the period"
                    },
                    "deadCaseIDs": {
                      "type": [
                        "string"
                      ],
                      "description": "Array containing the dead cases IDs in the Outbreak for the period. Present only if 'includeDeaths' filter is sent as true"
                    },
                    "deadConfirmedCaseIDs": {
                      "type": [
                        "string"
                      ],
                      "description": "Array containing the dead confirmed cases IDs in the Outbreak for the period. Present only if 'includeDeaths' filter is sent as true"
                    }
                  }
                }
              ]
            }
          },
          "description": "Object containing counters for cases per period",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of cases per period",
      "http": {
        "verb": "get",
        "path": "/cases/per-period-per-classification/count"
      }
    },
    "prototype.listLatestFollowUpsForContactsIfNotPerformed": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "follow-ups",
          "type": [
            "followUp"
          ],
          "description": "Array containing latest follow-ups missed by contacts. Doesn't return a missed follow-up if there is a new one for the same contact that was performed",
          "root": true,
          "required": true
        }
      ],
      "description": "List the latest follow-ups for contacts if were not performed. Doesn't return a missed follow-up if there is a new one for the same contact that was performed",
      "http": {
        "verb": "get",
        "path": "/follow-ups/latest-by-contacts-if-not-performed"
      }
    },
    "prototype.filteredCountLatestFollowUpsForContactsIfNotPerformed": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of latest follow-ups for contacts if were not performed",
          "required": true
        }
      ],
      "description": "Count the latest follow-ups for contacts if were not performed. Doesn't count a missed follow-up if there is a new one for the same contact that was performed",
      "http": {
        "verb": "get",
        "path": "/follow-ups/latest-by-contacts-if-not-performed/filtered-count"
      }
    },
    "prototype.listInconsistenciesInKeyDates": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "Array containing contacts/cases where inconsistencies were found between dates. Besides the contact/case properties each entry will also contain an 'inconsistencies' property (array of inconsistencies)",
          "root": true,
          "required": true
        }
      ],
      "description": "List of contacts/cases where inconsistencies were found between dates. Besides the contact/case properties each entry will also contain an 'inconsistencies' property (array of inconsistencies)",
      "http": {
        "verb": "get",
        "path": "/people/inconsistencies-in-key-dates"
      }
    },
    "prototype.restoreReferenceData": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for reference data"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "referenceData",
          "type": [
            "referenceData"
          ],
          "description": "Reference Data",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted Reference Data.",
      "http": {
        "verb": "post",
        "path": "/reference-data/:nk/restore"
      }
    },
    "prototype.importableFileUpload": {
      "accepts": [
        {
          "arg": "req",
          "type": "object",
          "http": {
            "source": "req"
          }
        },
        {
          "arg": "file",
          "type": "file"
        },
        {
          "arg": "model",
          "type": "string"
        },
        {
          "arg": "decryptPassword",
          "type": "string",
          "description": "If provided, the imported file will be decrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "result",
          "type": {
            "id": "string",
            "fileHeaders": [
              "string"
            ],
            "suggestedFieldMapping": {
              "type": {
                "<fileHeader>": {
                  "type": "string",
                  "description": "Model property"
                }
              }
            },
            "modelProperties": {
              "type": {
                "<modelProperty>": [
                  {
                    "type": "string",
                    "description": "Model property label"
                  }
                ]
              }
            },
            "modelPropertyValues": {
              "type": {
                "<modelProperty>": [
                  {
                    "type": "string",
                    "description": "Available values for a model property"
                  }
                ]
              }
            },
            "distinctFileColumnValues": {
              "type": {
                "<fileHeader>": [
                  {
                    "type": "string",
                    "description": "Distinct values for column"
                  }
                ]
              }
            }
          },
          "root": true,
          "required": true
        }
      ],
      "description": "Upload a file and get file headers",
      "http": {
        "verb": "post",
        "path": "/importable-files"
      }
    },
    "prototype.getImportableFileJsonById": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Importable file ID",
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "json",
          "type": [
            "any"
          ],
          "required": true,
          "root": true
        }
      ],
      "description": "Retrieve JSON version of an uploaded file",
      "http": {
        "verb": "get",
        "path": "/importable-files/:id/json"
      }
    },
    "prototype.importImportableLabResultsFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "labResults",
          "type": [
            "labResult"
          ],
          "root": true,
          "required": true
        }
      ],
      "description": "Import a list of lab results from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/cases/lab-results/import-importable-file-using-map"
      }
    },
    "prototype.exportCaseInvestigationTemplate": {
      "accepts": [
        {
          "arg": "copies",
          "type": "number",
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export pdf containing case investigation template",
      "http": {
        "verb": "get",
        "path": "/cases/export-investigation-template"
      }
    },
    "prototype.contactDossier": {
      "accepts": [
        {
          "arg": "contacts",
          "type": [
            "string"
          ],
          "description": "Array of contacts for which the dossiers will be generated"
        },
        {
          "arg": "data",
          "type": [
            "string"
          ],
          "description": "Array of fields to be anonymized"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export dossier for one or more contacts",
      "http": {
        "verb": "post",
        "ignoreActiveOutbreak": true,
        "path": "/contacts/dossier"
      }
    },
    "prototype.caseDossier": {
      "accepts": [
        {
          "arg": "cases",
          "type": [
            "string"
          ],
          "description": "Array of cases for which the dossiers will be generated"
        },
        {
          "arg": "data",
          "type": [
            "string"
          ],
          "description": "Array of fields to be anonymized"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export dossier for one or more cases",
      "http": {
        "verb": "post",
        "ignoreActiveOutbreak": true,
        "path": "/cases/dossier"
      }
    },
    "prototype.importImportableCasesFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "cases",
          "type": [
            "case"
          ],
          "root": true,
          "required": true
        }
      ],
      "description": "Import a list of cases from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/cases/import-importable-file-using-map"
      }
    },
    "prototype.importImportableContactsFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "contact"
          ],
          "root": true,
          "required": true
        }
      ],
      "description": "Import a list of contacts from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/contacts/import-importable-file-using-map"
      }
    },
    "prototype.countContactsPerLocation": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'date': 'date', 'locationId': 'locationId' on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "totalRegisteredContactsCount": {
              "type": "number",
              "description": "Total number of registered contacts for the outbreak"
            },
            "releasedContactsCount": {
              "type": "number",
              "description": "Number of released contacts for the outbreak"
            },
            "contactsUnderFollowUpCount": {
              "type": "number",
              "description": "Number of contacts for the outbreak that are still under follow-up"
            },
            "contactsSeenOnDateCount": {
              "type": "number",
              "description": "Number of contacts for the outbreak that were seen at their last follow-up"
            },
            "lastContactDateOfRelease": {
              "type": "date",
              "description": "Expected release of last contact in the outbreak (latest follow-up date for a contact)"
            },
            "locations": {
              "type": [
                {
                  "type": {
                    "id": "string",
                    "totalRegisteredContactsCount": "number",
                    "releasedContactsCount": "number",
                    "contactsUnderFollowUpCount": "number",
                    "contactsSeenOnDateCount": "number",
                    "lastContactDateOfRelease": "date",
                    "contactIDs": [
                      "string"
                    ]
                  }
                }
              ],
              "description": "Object containing counters for contacts per location"
            }
          },
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of contacts per location; Include counters for contacts under follow-up, contacts seen on date, contacts released as well as date for expected release of last contact",
      "http": {
        "verb": "get",
        "path": "/contacts/per-location/count"
      }
    },
    "prototype.exportFilteredContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "xml",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, xml, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export filtered list of contacts",
      "http": {
        "verb": "get",
        "path": "/contacts/export"
      }
    },
    "prototype.exportFilteredContactFollowUps": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'includeContactAddress': boolean, 'includeContactPhoneNumber': boolean, 'groupResultsBy': enum ['case', 'location', 'riskLevel'] on the first level in 'where'"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export filtered list of cases",
      "http": {
        "verb": "get",
        "path": "/contacts/follow-ups/export"
      }
    },
    "prototype.exportFilteredReferenceData": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "xml",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, xml, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export filtered list of reference data",
      "http": {
        "verb": "get",
        "path": "/reference-data/export"
      }
    },
    "prototype.importImportableReferenceDataFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "referenceData",
          "type": [
            "referenceData"
          ],
          "root": true,
          "required": true
        }
      ],
      "description": "Import a list of reference data from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/reference-data/import-importable-file-using-map"
      }
    },
    "prototype.findPeopleInCluster": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "ID of the cluster"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). This accepts a 'where.relationship' query."
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "List of people in the cluster",
          "required": true,
          "root": true
        }
      ],
      "description": "Find the people inside a cluster",
      "http": {
        "verb": "get",
        "path": "/clusters/:fk/people"
      }
    },
    "prototype.countPeopleInCluster": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "ID of the cluster"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). This accepts 'where.relationship' query."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of people in the cluster",
          "required": true
        }
      ],
      "description": "Number the people inside a cluster",
      "http": {
        "verb": "get",
        "path": "/clusters/:fk/people/count"
      }
    },
    "prototype.findFollowUps": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.contact', 'where.case' MongoDB compatible queries, where.timeLastSeen', 'where.weekNumber' queries"
        }
      ],
      "returns": [
        {
          "arg": "followUps",
          "type": [
            "followUp"
          ],
          "description": "List of followUps that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries followUps of outbreak.",
      "http": {
        "verb": "get",
        "path": "/followUps"
      }
    },
    "prototype.filteredCountFollowUps": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.contact', 'where.case' MongoDB compatible queries, where.timeLastSeen', 'where.weekNumber' queries"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of follow-ups that pass the filter",
          "required": true
        }
      ],
      "description": "Counts the follow-ups that pass a filter (which now can accept relations)",
      "http": {
        "verb": "get",
        "path": "/follow-ups/filtered-count"
      }
    },
    "prototype.filteredCountCaseRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships (that pass the filter) of a case",
          "required": true
        }
      ],
      "description": "Counts the relationships that pass a filter (which now can accept relations) of a case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/filteredCount"
      }
    },
    "prototype.filteredCountContactRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships (that pass the filter) of a contact",
          "required": true
        }
      ],
      "description": "Counts the relationships that pass a filter (which now can accept relations) of a case",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/filteredCount"
      }
    },
    "prototype.filteredCountEventRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships (that pass the filter) of an event",
          "required": true
        }
      ],
      "description": "Counts the relationships that pass a filter (which now can accept relations) of a case",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/filtered-count"
      }
    },
    "prototype.exportFilteredFollowups": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "xml",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, xml, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export filtered list of follow ups",
      "http": {
        "verb": "get",
        "path": "/follow-ups/export"
      }
    },
    "prototype.exportExistingEmptyCaseInvestigation": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export an empty case investigation for an existing case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/export-empty-case-investigation"
      }
    },
    "prototype.findPossiblePersonDuplicates": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note that filter.where needs to be a valid MongoDB where condition, not loopback, because the query is ran directly on MongoDB for performance reasons."
        }
      ],
      "returns": [
        {
          "arg": "duplicates",
          "type": {
            "peopleMap": {
              "type": {
                "<personId>": "person"
              }
            },
            "groups": [
              {
                "type": {
                  "duplicateKey": {
                    "type": "string",
                    "description": "The key/rule (name, phoneNumber, documents) that was matched by all the records in the group"
                  },
                  "indexKey": {
                    "type": "string",
                    "description": "They (constructed) key that was matched by all the records in the group"
                  },
                  "peopleIds": [
                    "string"
                  ]
                }
              }
            ]
          },
          "description": "Possible duplicate people groups",
          "root": true,
          "required": true
        }
      ],
      "description": "Find the possible duplicate people groups",
      "http": {
        "verb": "get",
        "path": "/people/possible-duplicates"
      }
    },
    "prototype.countPossiblePersonDuplicates": {
      "accepts": [
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances. Note that this needs to be a valid MongoDB where condition, not loopback, because the query is ran directly on MongoDB for performance reasons."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of possible duplicate people groups",
          "required": true
        }
      ],
      "description": "Count the number of possible duplicate people groups",
      "http": {
        "verb": "get",
        "path": "/people/possible-duplicates/count"
      }
    },
    "prototype.createCaseMultipleContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "data",
          "type": [
            "contactAndRelationship"
          ],
          "description": "Array containing pairs for contact + relationship",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "createResponse",
          "type": [
            "contactAndRelationship"
          ],
          "description": "Array of responses for the create actions",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates multiple contacts for a case.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/contacts"
      }
    },
    "prototype.createEventMultipleContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "data",
          "type": [
            "contactAndRelationship"
          ],
          "description": "Array containing pairs for contact + relationship",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "createResponse",
          "type": [
            "contactAndRelationship"
          ],
          "description": "Array of responses for the create actions",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates multiple contacts for a event.",
      "http": {
        "verb": "post",
        "path": "/events/:nk/contacts"
      }
    },
    "prototype.modifyCaseMultipleContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "data",
          "type": [
            "contact"
          ],
          "description": "Array containing contacts",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "createResponse",
          "type": [
            "contact"
          ],
          "description": "Array of updated contacts",
          "root": true,
          "required": true
        }
      ],
      "description": "Update multiple contacts for a case",
      "http": {
        "verb": "put",
        "path": "/cases/:nk/contacts"
      }
    },
    "prototype.findLabResults": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case' MongoDB compatible queries"
        }
      ],
      "returns": [
        {
          "arg": "labResults",
          "type": [
            "labResult"
          ],
          "description": "List of labResults that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries labResults of outbreak.",
      "http": {
        "verb": "get",
        "path": "/labResults"
      }
    },
    "prototype.filteredCountLabResults": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case' MongoDB compatible queries"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of lab results that pass the filter",
          "required": true
        }
      ],
      "description": "Counts the lab results that pass a filter",
      "http": {
        "verb": "get",
        "path": "/lab-results/filtered-count"
      }
    },
    "restoreOutbreak": {
      "accepts": [
        {
          "arg": "id",
          "type": "string",
          "description": "Outbreak ID"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "outbreak",
          "type": "outbreak",
          "description": "Outbreak",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted outbreak.",
      "http": {
        "verb": "post",
        "path": "/:id/restore"
      }
    },
    "prototype.findCaseRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "exposures",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship exposures of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship exposures of case.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/exposures"
      }
    },
    "prototype.countCaseRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship exposures (that pass the filter) of a case",
          "required": true
        }
      ],
      "description": "Counts the relationship exposures that pass a filter of a case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/exposures/filtered-count"
      }
    },
    "prototype.findCaseRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship contacts of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship contacts of case.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/contacts"
      }
    },
    "prototype.countCaseRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship contacts (that pass the filter) of a case",
          "required": true
        }
      ],
      "description": "Counts the relationship contacts that pass a filter of a case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/contacts/filtered-count"
      }
    },
    "prototype.findContactRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "exposures",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship exposures of a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship exposures of contact.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/exposures"
      }
    },
    "prototype.countContactRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship exposures (that pass the filter) of a contact",
          "required": true
        }
      ],
      "description": "Counts the relationship exposures that pass a filter of a contact",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/exposures/filtered-count"
      }
    },
    "prototype.findContactRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship contacts of a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship contacts of contacts.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/contacts"
      }
    },
    "prototype.countContactRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship contacts (that pass the filter) of a contact",
          "required": true
        }
      ],
      "description": "Counts the relationship contacts that pass a filter of a contact",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/contacts/filtered-count"
      }
    },
    "prototype.findEventRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "exposures",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship exposures of a event",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship exposures of event.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/exposures"
      }
    },
    "prototype.countEventRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship exposures (that pass the filter) of a event",
          "required": true
        }
      ],
      "description": "Counts the relationship exposures that pass a filter of a event",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/exposures/filtered-count"
      }
    },
    "prototype.findEventRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship contacts of a event",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship contacts of event.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/contacts"
      }
    },
    "prototype.countEventRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship contacts (that pass the filter) of a event",
          "required": true
        }
      ],
      "description": "Counts the relationship contacts that pass a filter of a event",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/contacts/filtered-count"
      }
    },
    "prototype.countCasesPerClassification": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: it supports same filters as GET /outbreak/:id/cases"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "classification": {
              "type": {
                "<caseClassification>": {
                  "type": {
                    "count": "number",
                    "caseIDs": [
                      "string"
                    ]
                  }
                }
              }
            },
            "count": "number"
          },
          "description": "Number of cases grouped by case classification",
          "required": true,
          "root": true
        }
      ],
      "description": "Counts the number of cases grouped by case classification",
      "http": {
        "verb": "get",
        "path": "/cases/per-classification/count"
      }
    },
    "prototype.countContactsPerRiskLevel": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: it supports same filters as GET /outbreak/:id/contacts"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "riskLevel": {
              "type": {
                "<riskLevel>": {
                  "type": {
                    "count": "number",
                    "contactIDs": [
                      "string"
                    ]
                  }
                }
              }
            },
            "count": "number"
          },
          "description": "Number of contacts grouped by case risk level",
          "required": true,
          "root": true
        }
      ],
      "description": "Counts the number of contacts grouped by case risk level",
      "http": {
        "verb": "get",
        "path": "/contacts/per-risk-level/count"
      }
    },
    "prototype.countCasesStratifiedByClassificationOverTime": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: this request also accepts 'periodType': enum [day, week, month], 'endDate' on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "<periodIndex>": {
              "type": {
                "start": "date",
                "end": "date",
                "classification": {
                  "type": {
                    "{caseClassification}": {
                      "type": "number",
                      "description": "Number of cases in the classification for the period"
                    }
                  }
                },
                "total": {
                  "type": "number",
                  "description": "Total number of cases for the period"
                }
              }
            }
          },
          "description": "Number of cases stratified by classification over time",
          "required": true,
          "root": true
        }
      ],
      "description": "Count cases stratified by classification over time",
      "http": {
        "verb": "get",
        "path": "/cases/classification-over-time/count"
      }
    },
    "prototype.countCasesStratifiedByOutcomeOverTime": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: this request also accepts 'periodType': enum [day, week, month], 'endDate' on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "<periodIndex>": {
              "type": {
                "start": "date",
                "end": "date",
                "outcome": {
                  "type": {
                    "{caseOutcome}": {
                      "type": "number",
                      "description": "Number of cases for the outcome for the period"
                    }
                  }
                },
                "total": {
                  "type": "number",
                  "description": "Total number of cases for the period"
                }
              }
            }
          },
          "description": "Number of cases stratified by outcome over time",
          "required": true,
          "root": true
        }
      ],
      "description": "Count cases stratified by outcome over time",
      "http": {
        "verb": "get",
        "path": "/cases/outcome-over-time/count"
      }
    },
    "prototype.countCasesStratifiedByClassificationOverReportingTime": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: this request also accepts 'periodType': enum [day, week, month], 'endDate' on the first level in 'where'"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "<periodIndex>": {
              "type": {
                "start": "date",
                "end": "date",
                "classification": {
                  "type": {
                    "{caseClassification}": {
                      "type": "number",
                      "description": "Number of cases in the classification for the reporting period"
                    }
                  }
                },
                "total": {
                  "type": "number",
                  "description": "Total number of cases for the reporting period"
                }
              }
            }
          },
          "description": "Number of cases stratified by classification over reporting time",
          "required": true,
          "root": true
        }
      ],
      "description": "Count cases stratified by classification over reporting time",
      "http": {
        "verb": "get",
        "path": "/cases/classification-over-reporting-time/count"
      }
    },
    "prototype.countFollowUpsByTeam": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "team": {
              "type": {
                "<teamId>": {
                  "type": {
                    "team": "team",
                    "followUpIds": [
                      "string"
                    ],
                    "count": "number"
                  }
                }
              }
            },
            "count": {
              "type": "number",
              "description": "Total number of follow-ups"
            }
          },
          "description": "Number of follow-ups grouped by team",
          "required": true,
          "root": true
        }
      ],
      "description": "Count follow-ups grouped by team",
      "http": {
        "verb": "get",
        "path": "/follow-ups/per-team/count"
      }
    },
    "prototype.attachmentUpload": {
      "accepts": [
        {
          "arg": "req",
          "type": "object",
          "http": {
            "source": "req"
          }
        },
        {
          "arg": "name",
          "type": "string"
        },
        {
          "arg": "file",
          "type": "file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "file",
          "type": "fileAttachment",
          "root": true
        }
      ],
      "description": "Upload a new attachment.",
      "http": {
        "verb": "post",
        "path": "/attachments"
      }
    },
    "prototype.attachmentDownload": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for attachments"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Download an attachment.",
      "http": {
        "verb": "get",
        "path": "/attachments/:fk/download"
      }
    },
    "prototype.bulkCreateRelationships": {
      "accepts": [
        {
          "arg": "sources",
          "type": [
            "string"
          ],
          "description": "List of people (cases/events) IDs to be used as source of the relationship"
        },
        {
          "arg": "targets",
          "type": [
            "string"
          ],
          "description": "List of people IDs to be used as target of the relationship"
        },
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Common relationship data"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "root": true,
          "required": true,
          "description": "List of created relationships"
        }
      ],
      "description": "Bulk create relationships.",
      "http": {
        "verb": "post",
        "path": "/relationships/bulk"
      }
    },
    "prototype.downloadCaseClassificationPerLocationLevelReport": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export a case classification per location report for an outbreak",
      "http": {
        "verb": "get",
        "path": "/cases/per-classification-per-location-level-report/download"
      }
    },
    "prototype.countCasesPerLocationLevel": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "result",
          "type": {
            "locations": [
              {
                "type": {
                  "location": {
                    "type": "location"
                  },
                  "caseIds": {
                    "type": "string"
                  },
                  "casesCount": {
                    "type": "number"
                  }
                }
              }
            ],
            "count": {
              "type": "number"
            }
          },
          "description": "Collection of items with location, cases and numberOfCases properties",
          "root": true,
          "required": true
        }
      ],
      "description": "Return an array of locations and the cases (that pass a filter) assigned to those locations",
      "http": {
        "verb": "get",
        "path": "/cases/per-location-level/count"
      }
    },
    "prototype.downloadContactTracingPerLocationLevelReport": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export a contact tracing per location report for an outbreak",
      "http": {
        "verb": "get",
        "path": "/contacts/per-location-level-tracing-report/download"
      }
    },
    "prototype.countContactsPerLocationLevel": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Accepts custom parameter dateOfFollowUp."
        }
      ],
      "returns": [
        {
          "arg": "result",
          "type": {
            "locations": [
              {
                "type": {
                  "location": {
                    "type": "location"
                  },
                  "contactIds": {
                    "type": "string"
                  },
                  "contactsCount": {
                    "type": "number"
                  }
                }
              }
            ],
            "count": {
              "type": "number"
            }
          },
          "description": "Collection of items with location, cases and numberOfCases properties",
          "root": true,
          "required": true
        }
      ],
      "description": "Return an array of locations and the contacts (that pass a filter) assigned to those locations",
      "http": {
        "verb": "get",
        "path": "/contacts/per-location-level/count"
      }
    },
    "prototype.getCaseMovement": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for cases"
        }
      ],
      "returns": [
        {
          "arg": "movement",
          "type": [
            "address"
          ],
          "description": "List of addresses with GeoLocations ordered from the oldest one to the most recent",
          "root": true,
          "required": true
        }
      ],
      "description": "Get list of addresses with GeoLocations ordered from the oldest one to the most recent",
      "http": {
        "verb": "get",
        "path": "/cases/:fk/movement"
      }
    },
    "prototype.getContactMovement": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for contacts"
        }
      ],
      "returns": [
        {
          "arg": "movement",
          "type": [
            "address"
          ],
          "description": "List of addresses with GeoLocations ordered from the oldest one to the most recent",
          "root": true,
          "required": true
        }
      ],
      "description": "Get list of addresses with GeoLocations ordered from the oldest one to the most recent",
      "http": {
        "verb": "get",
        "path": "/contacts/:fk/movement"
      }
    },
    "prototype.__get__people": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: it supports 'identifier' property on the first level of where. This allows searching people based on id, visualId and documents.number"
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "List of people that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries people of outbreak.",
      "http": {
        "verb": "get",
        "path": "/people"
      }
    },
    "prototype.findCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.relationship', 'where.labResult' MongoDB compatible queries and 'where.noRelationships' query"
        }
      ],
      "returns": [
        {
          "arg": "cases",
          "type": [
            "case"
          ],
          "description": "List of cases that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries cases of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/cases"
        },
        {
          "verb": "post",
          "path": "/cases/filter"
        }
      ]
    },
    "prototype.filteredCountCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.relationship', 'where.labResult' MongoDB compatible queries and 'where.noRelationships' query"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of cases that match the search criteria",
          "required": true
        }
      ],
      "description": "Counts cases of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/cases/filtered-count"
        },
        {
          "verb": "post",
          "path": "/cases/filtered-count"
        }
      ]
    },
    "prototype.findContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case', 'where.followUp' MongoDB compatible queries"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "contact"
          ],
          "description": "List of contacts that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries contacts of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/contacts"
        },
        {
          "verb": "post",
          "path": "/contacts/filter"
        }
      ]
    },
    "prototype.caseDelayBetweenOnsetAndLabTesting": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "delays",
          "type": [
            {
              "type": {
                "dateOfOnset": "date",
                "dateSampleTaken": "date",
                "delay": {
                  "type": "number",
                  "description": "Number of days between date of onset and the date of the first lab test sample"
                },
                "case": "case"
              }
            }
          ],
          "description": "List of entries that show the delay between date of symptom onset and the lab testing for a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Get a list of entries that show the delay between date of symptom onset and the lab testing for a case",
      "http": {
        "verb": "get",
        "path": "/cases/delay-onset-lab-testing"
      }
    },
    "prototype.exportContactFollowUpListPerDay": {
      "accepts": [
        {
          "arg": "res",
          "type": "object",
          "http": {
            "source": "res"
          }
        },
        {
          "arg": "date",
          "type": "date"
        },
        {
          "arg": "contactId",
          "type": "string"
        },
        {
          "arg": "groupBy",
          "type": "string",
          "enum": ["place", "case"]
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case', 'where.followUp' MongoDB compatible queries"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export a pdf file with the daily contact follow-up form, for every relevant contact, from a specific day",
      "http": {
        "verb": "get",
        "path": "/contacts/daily-followup-form/export"
      }
    },
    "prototype.restoreLabResult": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for lab results"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "labResult",
          "type": "labResult",
          "description": "Lab Result",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted lab result.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/lab-results/:fk/restore"
      }
    },
    "prototype.exportDailyContactFollowUpList": {
      "accepts": [
        {
          "arg": "res",
          "type": "object",
          "http": {
            "source": "res"
          }
        },
        {
          "arg": "groupBy",
          "type": "string"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case', 'where.followUp' MongoDB compatible queries"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export pdf containing contacts to be seen by place/case",
      "http": {
        "verb": "get",
        "path": "/contacts/daily-list/export"
      }
    },
    "prototype.exportRangeListOfContacts": {
      "accepts": [
        {
          "arg": "data",
          "type": "object",
          "model": "exportRangeContacts",
          "description": "Group By (case, place, risk level), Range Date properties",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export pdf containing range of contacts to be seen by place/case",
      "http": {
        "verb": "post",
        "ignoreActiveOutbreak": true,
        "path": "/contacts/range-list/export"
      }
    },
    "prototype.filteredCountContactsOnFollowUpList": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "contactsCount",
          "type": "number",
          "description": "Number of contacts (that pass the filter) on the follow up list",
          "required": true
        },
        {
          "arg": "contactIDs",
          "type": [
            "string"
          ],
          "description": "Ids of contacts (that pass the filter) on the follow up list",
          "required": true
        }
      ],
      "description": "Counts the contacts that are on the follow up list, that pass a filter.",
      "http": {
        "verb": "get",
        "path": "/contacts/on-follow-up-list/count"
      }
    },
    "prototype.getContactPossibleDuplicates": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter offset and limit - must be a JSON-encoded string ({\"something\":\"value\"}).",
          "http": {
            "source": "query"
          },
          "required": true
        },
        {
          "arg": "data",
          "type": "object",
          "model": "contact",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "duplicates",
          "type": ["contact"],
          "description": "List of contacts that are duplicates",
          "required": true
        }
      ],
      "description": "Get list of contacts that are possible duplicates",
      "http": {
        "verb": "post",
        "path": "/contacts/duplicates/find"
      }
    },
    "prototype.getCasePossibleDuplicates": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter offset and limit - must be a JSON-encoded string ({\"something\":\"value\"}).",
          "http": {
            "source": "query"
          },
          "required": true
        },
        {
          "arg": "data",
          "type": "object",
          "model": "case",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "duplicates",
          "type": ["case"],
          "description": "List of cases that are duplicates",
          "required": true
        }
      ],
      "description": "Get list of cases that are possible duplicates",
      "http": {
        "verb": "post",
        "path": "/cases/duplicates/find"
      }
    },
    "prototype.caseDelayBetweenOnsetAndHospitalizationIsolation": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "delays",
          "type": [
            {
              "type": {
                "dateOfOnset": "date",
                "hospitalizationIsolationDate": "date",
                "delay": {
                  "type": "number",
                  "description": "Number of days between date of onset and the first hospitalization/isolation date of the case"
                },
                "case": "case"
              }
            }
          ],
          "description": "List of entries that show the delay between date of symptom onset and hospitalization/isolation date of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Get a list of entries that show the delay between date of symptom onset and hospitalization/isolation date of a case",
      "http": {
        "verb": "get",
        "path": "/cases/delay-onset-hospitalization"
      }
    },
    "prototype.getContactFollowUpReport": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "dateRange",
          "description": "Start/end dates",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "report",
          "type": "object",
          "description": "Report",
          "required": true
        }
      ],
      "description": "Get total number of contacts that were followed up in the given period of time",
      "http": {
        "verb": "post",
        "path": "/contacts/follow-up-report"
      }
    },
    "prototype.getFollowUpsGroupedByContact": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "data",
          "type": "object",
          "root": true,
          "description": "List of follow ups grouped by contact",
          "required": true
        }
      ],
      "description": "Get list of follow ups grouped by contact and pagination support",
      "http": {
        "verb": "get",
        "path": "/range-follow-ups"
      }
    },
    "prototype.countFollowUpsGroupedByContact": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "data",
          "type": "object",
          "root": true,
          "description": "Count groups of follow ups",
          "required": true
        }
      ],
      "description": "Count list of follow ups grouped by contact",
      "http": {
        "verb": "get",
        "path": "/range-follow-ups/count"
      }
    }
  }
}
