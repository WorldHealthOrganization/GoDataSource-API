{
  "name": "outbreak",
  "base": "extendedPersistedModel",
  "idInjection": true,
  "options": {
    "validateUpsert": true
  },
  "scope": {
    "order": [
      "name ASC"
    ]
  },
  "properties": {
    "name": {
      "type": "string",
      "required": true,
      "unique": true
    },
    "description": {
      "type": "string"
    },
    "disease": {
      "type": "string"
    },
    "countries": {
      "type": [
        "country"
      ]
    },
    "locationIds": [
      "string"
    ],
    "startDate": {
      "type": "date",
      "required": true
    },
    "endDate": {
      "type": "date"
    },
    "longPeriodsBetweenCaseOnset": {
      "type": "number",
      "description": "Number of days used for defining long periods in the dates of onset between cases in the chain of transmission",
      "required": true
    },
    "periodOfFollowup": {
      "type": "number",
      "description": "Duration for the follow-up period in days",
      "required": true
    },
    "frequencyOfFollowUp": {
      "type": "number",
      "required": true,
      "default": 1,
      "description": "Frequency of follow ups in days (once every X days/daily)"
    },
    "frequencyOfFollowUpPerDay": {
      "type": "number",
      "required": true,
      "description": "Number of follow ups to be generated per day"
    },
    "generateFollowUpsOverwriteExisting": {
      "description": "Flag specifying whether existing follow-ups in the specified period will be overwritten or not. Applies only to not performed follow-ups",
      "type": "boolean",
      "default": false
    },
    "generateFollowUpsKeepTeamAssignment": {
      "description": "Flag specifying whether new generated follow-ups will be assigned to the same team as the last follow-up for a contact or the team assignment will be made through round-robin (can be true only if 'generateFollowUpsOverwriteExisting' is false)",
      "type": "boolean",
      "default": true
    },
    "generateFollowUpsTeamAssignmentAlgorithm": {
      "description": "Option specifying whether the round-robin team assignment should be done taking in consideration all teams activating in the contact's location (via that location or parents) or just the nearest teams. Default: round-robin of all teams activating in the contact's location",
      "type": "string",
      "enum": [
        "LNG_REFERENCE_DATA_CATEGORY_FOLLOWUP_GENERATION_TEAM_ASSIGNMENT_ALGORITHM_ROUND_ROBIN_ALL_TEAMS",
        "LNG_REFERENCE_DATA_CATEGORY_FOLLOWUP_GENERATION_TEAM_ASSIGNMENT_ALGORITHM_ROUND_ROBIN_NEAREST_FIT"
      ],
      "default": "LNG_REFERENCE_DATA_CATEGORY_FOLLOWUP_GENERATION_TEAM_ASSIGNMENT_ALGORITHM_ROUND_ROBIN_ALL_TEAMS"
    },
    "generateFollowUpsDateOfLastContact": {
      "description": "Flag specifying if contact tracing should start on the date of the last contact",
      "type": "boolean",
      "default": false
    },
    "intervalOfFollowUp": {
      "description": "Option specifying the interval when follow-ups should be generated. If empty then no restrictions will be applied, otherwise it will generate follow-ups only on specific days (interval sample: '1, 3, 5')",
      "type": "string"
    },
    "noDaysAmongContacts": {
      "type": "number",
      "required": true,
      "description": "Number of days used to calculate the proportion of new cases detected among known contacts"
    },
    "noDaysInChains": {
      "type": "number",
      "required": true,
      "description": "Number of days used to calculate the proportion of new cases in known transmission chains"
    },
    "noDaysNotSeen": {
      "type": "number",
      "required": true,
      "description": "Number of days used to filter a list of contacts not seen for a specific number of days"
    },
    "noLessContacts": {
      "type": "number",
      "required": true,
      "description": "Number of contacts used to determine the proportion of cases with less than X contacts"
    },
    "noDaysNewContacts": {
      "type": "number",
      "description": "Number of days used to determine if a contact is new",
      "default": 1
    },
    "fieldsToDisplayNode": {
      "type": [
        "string"
      ]
    },
    "caseInvestigationTemplate": {
      "type": [
        "templateQuestion"
      ],
      "default": [],
      "importTopLevelOnly": true
    },
    "contactInvestigationTemplate": {
      "type": [
        "templateQuestion"
      ],
      "default": [],
      "importTopLevelOnly": true
    },
    "contactFollowUpTemplate": {
      "type": [
        "templateQuestion"
      ],
      "default": [],
      "importTopLevelOnly": true
    },
    "labResultsTemplate": {
      "type": [
        "templateQuestion"
      ],
      "default": [],
      "importTopLevelOnly": true
    },
    "caseIdMask": {
      "type": "string",
      "required": true,
      "pattern": "^(?:9*[^9()]*|[^9()]*9*[^9()]*|[^9()]*9*)$",
      "default": "9999999999"
    },
    "contactIdMask": {
      "type": "string",
      "required": true,
      "pattern": "^(?:9*[^9()]*|[^9()]*9*[^9()]*|[^9()]*9*)$",
      "default": "9999999999"
    },
    "arcGisServers": [
      "arcGisServer"
    ],
    "reportingGeographicalLevelId": {
      "type": "string",
      "description": "The maximum geographical level of locations from which reports data is gathered"
    },
    "isContactLabResultsActive": {
      "type": "boolean",
      "default": false
    },
    "contactOfContactIdMask": {
      "type": "string",
      "required": true,
      "pattern": "^(?:9*[^9()]*|[^9()]*9*[^9()]*|[^9()]*9*)$",
      "default": "9999999999"
    },
    "isContactsOfContactsActive": {
      "type": "boolean",
      "default": false
    },
    "isDateOfOnsetRequired": {
      "description": "Flag specifying whether the case dateOfOnset property is required. Default: true",
      "type": "boolean",
      "default": true
    },
    "applyGeographicRestrictions": {
      "description": "Flag specifying whether the geographical restriction of data will be applied for the outbreak",
      "type": "boolean",
      "default": false
    }
  },
  "indexes": {
    "name_index": {
      "name": 1
    },
    "disease_index": {
      "disease": 1
    },
    "startDate_index": {
      "startDate": 1
    }
  },
  "validations": [],
  "relations": {
    "cases": {
      "type": "hasMany",
      "model": "case",
      "foreignKey": "outbreakId"
    },
    "clusters": {
      "type": "hasMany",
      "model": "cluster",
      "foreignKey": "outbreakId"
    },
    "contacts": {
      "type": "hasMany",
      "model": "contact",
      "foreignKey": "outbreakId"
    },
    "events": {
      "type": "hasMany",
      "model": "event",
      "foreignKey": "outbreakId"
    },
    "referenceData": {
      "type": "hasMany",
      "model": "referenceData",
      "foreignKey": "outbreakId"
    },
    "followUps": {
      "type": "hasMany",
      "model": "followUp",
      "foreignKey": "outbreakId"
    },
    "people": {
      "type": "hasMany",
      "model": "person",
      "foreignKey": "outbreakId"
    },
    "labResults": {
      "type": "hasMany",
      "model": "labResult",
      "foreignKey": "outbreakId"
    },
    "attachments": {
      "type": "hasMany",
      "model": "fileAttachment",
      "foreignKey": "outbreakId"
    },
    "contactsOfContacts": {
      "type": "hasMany",
      "model": "contactOfContact",
      "foreignKey": "outbreakId"
    },
    "transmissionChains": {
      "type": "hasMany",
      "model": "transmissionChain",
      "foreignKey": "outbreakId"
    }
  },
  "acls": [
    {
      "principalType": "ROLE",
      "principalId": "$everyone",
      "permission": "DENY"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "getLocationsHierarchicalList"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "importableFileUpload"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "getImportableFileJsonById"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "find"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "count"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "__findById__attachments"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "attachmentUpload"
    },
    {
      "principalType": "ROLE",
      "principalId": "$client_application",
      "permission": "ALLOW",
      "property": "attachmentUpload"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "attachmentDownload"
    },
    {
      "principalType": "ROLE",
      "principalId": "$client_application",
      "permission": "ALLOW",
      "property": "attachmentDownload"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "__destroyById__attachments"
    },
    {
      "principalType": "ROLE",
      "principalId": "$client_application",
      "permission": "ALLOW",
      "property": "__destroyById__attachments"
    },
    {
      "principalType": "ROLE",
      "principalId": "outbreak_create",
      "permission": "ALLOW",
      "property": "create"
    },
    {
      "principalType": "ROLE",
      "principalId": "outbreak_modify",
      "permission": "ALLOW",
      "property": "patchAttributes"
    },
    {
      "principalType": "ROLE",
      "principalId": "outbreak_view",
      "permission": "ALLOW",
      "property": "findById"
    },
    {
      "principalType": "ROLE",
      "principalId": "outbreak_delete",
      "permission": "ALLOW",
      "property": "deleteById"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "findCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "__count__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "getCaseCountMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_create",
      "permission": "ALLOW",
      "property": "__create__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_view",
      "permission": "ALLOW",
      "property": "__findById__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_modify",
      "permission": "ALLOW",
      "property": "__updateById__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_delete",
      "permission": "ALLOW",
      "property": "__destroyById__cases"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list",
      "permission": "ALLOW",
      "property": "findContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list",
      "permission": "ALLOW",
      "property": "countContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_create",
      "permission": "ALLOW",
      "property": "__create__contacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_view",
      "permission": "ALLOW",
      "property": "__findById__contacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_modify",
      "permission": "ALLOW",
      "property": "__updateById__contacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_delete",
      "permission": "ALLOW",
      "property": "__destroyById__contacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_lab_result",
      "permission": "ALLOW",
      "property": "__get__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_lab_result",
      "permission": "ALLOW",
      "property": "__count__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_create_lab_result",
      "permission": "ALLOW",
      "property": "__create__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_view_lab_result",
      "permission": "ALLOW",
      "property": "__findById__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_modify_lab_result",
      "permission": "ALLOW",
      "property": "__updateById__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_delete_lab_result",
      "permission": "ALLOW",
      "property": "__destroyById__cases__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list_lab_result",
      "permission": "ALLOW",
      "property": "__get__contacts__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list_lab_result",
      "permission": "ALLOW",
      "property": "__count__contacts__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_create_lab_result",
      "permission": "ALLOW",
      "property": "__create__contacts__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_view_lab_result",
      "permission": "ALLOW",
      "property": "__findById__contacts__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_modify_lab_result",
      "permission": "ALLOW",
      "property": "__updateById__contacts__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_delete_lab_result",
      "permission": "ALLOW",
      "property": "__destroyById__contacts__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_list",
      "permission": "ALLOW",
      "property": "__get__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_list",
      "permission": "ALLOW",
      "property": "__count__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_create",
      "permission": "ALLOW",
      "property": "__create__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_view",
      "permission": "ALLOW",
      "property": "__findById__contacts__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_restore",
      "permission": "ALLOW",
      "property": "restoreContactFollowUp"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "findRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "countRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "findCaseRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "findContactRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "findEventRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "createCaseRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "createContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "createEventRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_reverse",
      "permission": "ALLOW",
      "property": "setTargetAndSourceForRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_view",
      "permission": "ALLOW",
      "property": "getCaseRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_view",
      "permission": "ALLOW",
      "property": "getContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_view",
      "permission": "ALLOW",
      "property": "getEventRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_modify",
      "permission": "ALLOW",
      "property": "updateCaseRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_modify",
      "permission": "ALLOW",
      "property": "updateContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_modify",
      "permission": "ALLOW",
      "property": "updateEventRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_delete",
      "permission": "ALLOW",
      "property": "deleteCaseRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_delete",
      "permission": "ALLOW",
      "property": "deleteContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_delete",
      "permission": "ALLOW",
      "property": "deleteEventRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "countCaseRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "filteredCountCaseRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "countContactRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "filteredCountContactRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "countEventRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "filteredCountEventRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_restore",
      "permission": "ALLOW",
      "property": "restoreEvent"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_list",
      "permission": "ALLOW",
      "property": "findEvents"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_create",
      "permission": "ALLOW",
      "property": "__create__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_view",
      "permission": "ALLOW",
      "property": "__findById__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_modify",
      "permission": "ALLOW",
      "property": "__updateById__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_delete",
      "permission": "ALLOW",
      "property": "__destroyById__events"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_list",
      "permission": "ALLOW",
      "property": "filteredCountEvents"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list",
      "permission": "ALLOW",
      "property": "getIndependentTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list",
      "permission": "ALLOW",
      "property": "calculateIndependentTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list",
      "permission": "ALLOW",
      "property": "getCalculatedIndependentTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list",
      "permission": "ALLOW",
      "property": "countIndependentTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "cluster_list",
      "permission": "ALLOW",
      "property": "__get__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "cluster_view",
      "permission": "ALLOW",
      "property": "__findById__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "cluster_create",
      "permission": "ALLOW",
      "property": "__create__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "cluster_modify",
      "permission": "ALLOW",
      "property": "__updateById__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "cluster_delete",
      "permission": "ALLOW",
      "property": "__destroyById__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "cluster_list",
      "permission": "ALLOW",
      "property": "__count__clusters"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_convert_to_case",
      "permission": "ALLOW",
      "property": "convertContactToCase"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_restore",
      "permission": "ALLOW",
      "property": "restoreContact"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_generate_visual_id",
      "permission": "ALLOW",
      "property": "generateContactVisualId"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_generate_visual_id",
      "permission": "ALLOW",
      "property": "generateCaseVisualId"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list",
      "permission": "ALLOW",
      "property": "filteredCountContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "duplicate_merge_cases",
      "permission": "ALLOW",
      "property": "mergePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "duplicate_merge_contacts",
      "permission": "ALLOW",
      "property": "mergePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "duplicate_merge_events",
      "permission": "ALLOW",
      "property": "mergePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "duplicate_merge_contacts_of_contacts",
      "permission": "ALLOW",
      "property": "mergePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_view_bar_chart",
      "permission": "ALLOW",
      "property": "getBarsTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_export",
      "permission": "ALLOW",
      "property": "exportFilteredRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "__get__people"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list",
      "permission": "ALLOW",
      "property": "__get__people"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_list",
      "permission": "ALLOW",
      "property": "__get__people"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list",
      "permission": "ALLOW",
      "property": "__get__people"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "countPeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list",
      "permission": "ALLOW",
      "property": "countPeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_list",
      "permission": "ALLOW",
      "property": "countPeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list",
      "permission": "ALLOW",
      "property": "countPeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "outbreak_see_inconsistencies",
      "permission": "ALLOW",
      "property": "listInconsistenciesInKeyDates"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_export_dossier",
      "permission": "ALLOW",
      "property": "contactDossier"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_import",
      "permission": "ALLOW",
      "property": "importImportableContactsFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_export",
      "permission": "ALLOW",
      "property": "exportFilteredContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "cluster_list_people",
      "permission": "ALLOW",
      "property": "findPeopleInCluster"
    },
    {
      "principalType": "ROLE",
      "principalId": "cluster_list_people",
      "permission": "ALLOW",
      "property": "countPeopleInCluster"
    },
    {
      "principalType": "ROLE",
      "principalId": "duplicate_list",
      "permission": "ALLOW",
      "property": "findPossiblePersonDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "duplicate_list",
      "permission": "ALLOW",
      "property": "countPossiblePersonDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_create_bulk_contact",
      "permission": "ALLOW",
      "property": "createCaseMultipleContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_create_bulk_contact",
      "permission": "ALLOW",
      "property": "createEventMultipleContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "outbreak_restore",
      "permission": "ALLOW",
      "property": "restoreOutbreak"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list_relationship_exposures",
      "permission": "ALLOW",
      "property": "findContactRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list_relationship_exposures",
      "permission": "ALLOW",
      "property": "countContactRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list_relationship_contacts",
      "permission": "ALLOW",
      "property": "findContactRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list_relationship_contacts",
      "permission": "ALLOW",
      "property": "countContactRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "getEventRelationshipsAvailablePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "countEventRelationshipsAvailablePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_list_relationship_exposures",
      "permission": "ALLOW",
      "property": "findEventRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_list_relationship_exposures",
      "permission": "ALLOW",
      "property": "countEventRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_list_relationship_contacts",
      "permission": "ALLOW",
      "property": "findEventRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_list_relationship_contacts",
      "permission": "ALLOW",
      "property": "countEventRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_share",
      "permission": "ALLOW",
      "property": "bulkCreateRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_bulk_delete",
      "permission": "ALLOW",
      "property": "bulkDeleteRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_change_target_relationships",
      "permission": "ALLOW",
      "property": "bulkChangeTargetRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_change_target_relationships",
      "permission": "ALLOW",
      "property": "bulkChangeTargetRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_change_target_relationships",
      "permission": "ALLOW",
      "property": "bulkChangeTargetRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_change_source_relationships",
      "permission": "ALLOW",
      "property": "bulkChangeSourceRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_change_source_relationships",
      "permission": "ALLOW",
      "property": "bulkChangeSourceRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_change_source_relationships",
      "permission": "ALLOW",
      "property": "bulkChangeSourceRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_change_source_relationships",
      "permission": "ALLOW",
      "property": "bulkChangeSourceRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_view_movement_map",
      "permission": "ALLOW",
      "property": "getContactMovement"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_bulk_modify",
      "permission": "ALLOW",
      "property": "bulkModifyContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "getContactRelationshipsAvailablePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "countContactRelationshipsAvailablePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "getCaseRelationshipsAvailablePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "countCaseRelationshipsAvailablePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list",
      "permission": "ALLOW",
      "property": "getContactPossibleDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list",
      "permission": "ALLOW",
      "property": "getContactMarkedAsNotDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_list",
      "permission": "ALLOW",
      "property": "getContactMarkedAsNotDuplicatesCount"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_modify",
      "permission": "ALLOW",
      "property": "contactMarkPersonAsOrNotADuplicate"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "getCasePossibleDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "getCaseMarkedAsNotDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "getCaseMarkedAsNotDuplicatesCount"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_modify",
      "permission": "ALLOW",
      "property": "caseMarkPersonAsOrNotADuplicate"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_export_daily_follow_up_list",
      "permission": "ALLOW",
      "property": "exportDailyContactFollowUpList"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_export_daily_follow_up_form",
      "permission": "ALLOW",
      "property": "exportDailyContactFollowUpForm"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_generate",
      "permission": "ALLOW",
      "property": "generateFollowups"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_bulk_modify",
      "permission": "ALLOW",
      "property": "bulkModifyFollowUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_list",
      "permission": "ALLOW",
      "property": "findFollowUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_list",
      "permission": "ALLOW",
      "property": "__count__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_view",
      "permission": "ALLOW",
      "property": "__findById__followUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_export",
      "permission": "ALLOW",
      "property": "exportFilteredFollowups"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_list",
      "permission": "ALLOW",
      "property": "filteredCountFollowUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_bulk_delete",
      "permission": "ALLOW",
      "property": "bulkDeleteFollowUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_bulk_restore",
      "permission": "ALLOW",
      "property": "bulkRestoreFollowUps"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_export_daily_form",
      "permission": "ALLOW",
      "property": "exportContactFollowUpListPerDay"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_grouped_by_team",
      "permission": "ALLOW",
      "property": "countFollowUpsByTeam"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_grouped_by_risk",
      "permission": "ALLOW",
      "property": "countContactsPerRiskLevel"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_export_range",
      "permission": "ALLOW",
      "property": "exportRangeListOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_list_range",
      "permission": "ALLOW",
      "property": "getFollowUpsGroupedByContact"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_list_range",
      "permission": "ALLOW",
      "property": "countFollowUpsGroupedByContact"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_view_movement_map",
      "permission": "ALLOW",
      "property": "getCaseMovement"
    },
    {
      "principalType": "ROLE",
      "principalId": "gantt_chart_view_delay_onset_lab_testing",
      "permission": "ALLOW",
      "property": "caseDelayBetweenOnsetAndLabTesting"
    },
    {
      "principalType": "ROLE",
      "principalId": "gantt_chart_view_delay_onset_hospitalization",
      "permission": "ALLOW",
      "property": "caseDelayBetweenOnsetAndHospitalizationIsolation"
    },
    {
      "principalType": "ROLE",
      "principalId": "team_list_workload",
      "permission": "ALLOW",
      "property": "countFollowUpsPerTeamPerDay"
    },
    {
      "principalType": "ROLE",
      "principalId": "user_list_workload",
      "permission": "ALLOW",
      "property": "countFollowUpsPerUserPerDay"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_convert_to_contact",
      "permission": "ALLOW",
      "property": "convertCaseToContact"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_restore",
      "permission": "ALLOW",
      "property": "restoreCase"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "filteredCountCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_export",
      "permission": "ALLOW",
      "property": "exportFilteredCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_export",
      "permission": "ALLOW",
      "property": "exportFilteredEvents"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_import_lab_result",
      "permission": "ALLOW",
      "property": "importImportableCaseLabResultsFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_import_lab_result",
      "permission": "ALLOW",
      "property": "importImportableContactLabResultsFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_export_dossier",
      "permission": "ALLOW",
      "property": "caseDossier"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_import",
      "permission": "ALLOW",
      "property": "importImportableCasesFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "event_import",
      "permission": "ALLOW",
      "property": "importImportableEventsFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "lab_result_list",
      "permission": "ALLOW",
      "property": "filteredCountLabResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "lab_result_list",
      "permission": "ALLOW",
      "property": "filteredCountCaseLabResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "lab_result_list",
      "permission": "ALLOW",
      "property": "filteredCountContactLabResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "lab_result_list",
      "permission": "ALLOW",
      "property": "findLabResultsAggregate"
    },
    {
      "principalType": "ROLE",
      "principalId": "lab_result_list",
      "permission": "ALLOW",
      "property": "filteredCountLabResultsAggregate"
    },
    {
      "principalType": "ROLE",
      "principalId": "lab_result_view",
      "permission": "ALLOW",
      "property": "__findById__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "lab_result_modify",
      "permission": "ALLOW",
      "property": "__updateById__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "lab_result_delete",
      "permission": "ALLOW",
      "property": "__destroyById__labResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_relationship_exposures",
      "permission": "ALLOW",
      "property": "findCaseRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_relationship_exposures",
      "permission": "ALLOW",
      "property": "countCaseRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_relationship_contacts",
      "permission": "ALLOW",
      "property": "findCaseRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_relationship_contacts",
      "permission": "ALLOW",
      "property": "countCaseRelationshipContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_restore_lab_result",
      "permission": "ALLOW",
      "property": "restoreCaseLabResult"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_restore_lab_result",
      "permission": "ALLOW",
      "property": "restoreContactLabResult"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_grouped_by_classification",
      "permission": "ALLOW",
      "property": "countCasesPerClassification"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list",
      "permission": "ALLOW",
      "property": "countCasesHospitalized"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_onset_before_primary_case_report",
      "permission": "ALLOW",
      "property": "findSecondaryCasesWithDateOfOnsetBeforePrimaryCase"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_long_period_between_onset_dates_report",
      "permission": "ALLOW",
      "property": "longPeriodsBetweenDatesOfOnsetInTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_isolated_cases",
      "permission": "ALLOW",
      "property": "getCaseIsolatedContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_export_investigation_form",
      "permission": "ALLOW",
      "property": "exportExistingEmptyCaseInvestigation"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_export_empty_investigation_forms",
      "permission": "ALLOW",
      "property": "exportCaseInvestigationTemplate"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_grouped_by_location_level",
      "permission": "ALLOW",
      "property": "countCasesPerLocationLevel"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_stratified_by_classification_over_time",
      "permission": "ALLOW",
      "property": "countCasesStratifiedByClassificationOverTime"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_stratified_by_outcome_over_time",
      "permission": "ALLOW",
      "property": "countCasesStratifiedByOutcomeOverTime"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_stratified_by_classification_over_reporting_time",
      "permission": "ALLOW",
      "property": "countCasesStratifiedByClassificationOverReportingTime"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_view_follow_up_report",
      "permission": "ALLOW",
      "property": "getContactFollowUpReport"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_cases_by_period_and_contact_status",
      "permission": "ALLOW",
      "property": "countCasesPerPeriodPerContactStatus"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_cases_with_less_than_x_contacts",
      "permission": "ALLOW",
      "property": "countCasesWithLessThanXContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_cases_new_in_previous_x_days_detected_among_contacts",
      "permission": "ALLOW",
      "property": "countNewCasesInThePreviousXDaysDetectedAmongKnownContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_list_cases_new_in_known_cot",
      "permission": "ALLOW",
      "property": "countNewCasesInKnownTransmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_count_case_contacts",
      "permission": "ALLOW",
      "property": "countCasesContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_count_from_follow_up",
      "permission": "ALLOW",
      "property": "filteredCountContactsOnFollowUpList"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_count_lost_to_follow_up",
      "permission": "ALLOW",
      "property": "countContactsLostToFollowup"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_count_not_seen_in_x_days",
      "permission": "ALLOW",
      "property": "countContactsNotSeenInXDays"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_count_seen",
      "permission": "ALLOW",
      "property": "countContactsSeen"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_count_successful_follow_ups",
      "permission": "ALLOW",
      "property": "countContactsWithSuccessfulFollowups"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list_new_from_contacts_became_cases",
      "permission": "ALLOW",
      "property": "buildNewChainsFromRegisteredContactsWhoBecameCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list_new_from_contacts_became_cases",
      "permission": "ALLOW",
      "property": "countNewChainsFromRegisteredContactsWhoBecameCases"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_export_classification_per_location_report",
      "permission": "ALLOW",
      "property": "downloadCaseClassificationPerLocationLevelReport"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_export_follow_up_success_rate_report",
      "permission": "ALLOW",
      "property": "downloadContactTracingPerLocationLevelReport"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_export_lab_result",
      "permission": "ALLOW",
      "property": "exportFilteredLabResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_export_lab_result",
      "permission": "ALLOW",
      "property": "exportFilteredLabResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "case_export_lab_result",
      "permission": "ALLOW",
      "property": "exportFilteredCaseLabResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_export_lab_result",
      "permission": "ALLOW",
      "property": "exportFilteredContactLabResults"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_import",
      "permission": "ALLOW",
      "property": "importImportableRelationshipsFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list",
      "permission": "ALLOW",
      "property": "findContactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list",
      "permission": "ALLOW",
      "property": "filteredCountContactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_create",
      "permission": "ALLOW",
      "property": "__create__contactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_view",
      "permission": "ALLOW",
      "property": "__findById__contactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_modify",
      "permission": "ALLOW",
      "property": "__updateById__contactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_delete",
      "permission": "ALLOW",
      "property": "__destroyById__contactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list",
      "permission": "ALLOW",
      "property": "__count__contactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "findContactOfContactRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "createContactOfContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_view",
      "permission": "ALLOW",
      "property": "getContactOfContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_modify",
      "permission": "ALLOW",
      "property": "updateContactOfContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_delete",
      "permission": "ALLOW",
      "property": "deleteContactOfContactRelationship"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_list",
      "permission": "ALLOW",
      "property": "countContactOfContactRelationships"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "getContactOfContactRelationshipsAvailablePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "relationship_create",
      "permission": "ALLOW",
      "property": "countContactOfContactRelationshipsAvailablePeople"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list_relationship_exposures",
      "permission": "ALLOW",
      "property": "findContactOfContactRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list_relationship_exposures",
      "permission": "ALLOW",
      "property": "countContactOfContactRelationshipExposures"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_export",
      "permission": "ALLOW",
      "property": "exportFilteredContactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_import",
      "permission": "ALLOW",
      "property": "importImportableContactsOfContactsFileUsingMap"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_generate_visual_id",
      "permission": "ALLOW",
      "property": "generateContactOfContactVisualId"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list",
      "permission": "ALLOW",
      "property": "getContactOfContactPossibleDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list",
      "permission": "ALLOW",
      "property": "getContactOfContactMarkedAsNotDuplicates"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_list",
      "permission": "ALLOW",
      "property": "getContactOfContactMarkedAsNotDuplicatesCount"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_modify",
      "permission": "ALLOW",
      "property": "contactOfContactMarkPersonAsOrNotADuplicate"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_restore",
      "permission": "ALLOW",
      "property": "restoreContactOfContact"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_export_dossier",
      "permission": "ALLOW",
      "property": "contactOfContactDossier"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_view_movement_map",
      "permission": "ALLOW",
      "property": "getContactOfContactMovement"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_grouped_by_risk",
      "permission": "ALLOW",
      "property": "countContactsOfContactsPerRiskLevel"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_of_contact_bulk_modify",
      "permission": "ALLOW",
      "property": "bulkModifyContactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "contact_create_bulk_contact_of_contact",
      "permission": "ALLOW",
      "property": "createContactMultipleContactsOfContacts"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_modify",
      "permission": "ALLOW",
      "property": "modifyContactFollowUp"
    },
    {
      "principalType": "ROLE",
      "principalId": "follow_up_delete",
      "permission": "ALLOW",
      "property": "deleteContactFollowUp"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list",
      "permission": "ALLOW",
      "property": "__get__transmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list",
      "permission": "ALLOW",
      "property": "__findById__transmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list",
      "permission": "ALLOW",
      "property": "__destroyById__transmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "cot_list",
      "permission": "ALLOW",
      "property": "__count__transmissionChains"
    },
    {
      "principalType": "ROLE",
      "principalId": "$authenticated",
      "permission": "ALLOW",
      "property": "exportFieldsGroup"
    }
  ],
  "methods": {
    "prototype.findCaseRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "Relationships of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationships of case.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships"
      }
    },
    "prototype.getCaseRelationshipsAvailablePeople": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "List of people that match the search criteria and belong to a case. Includes matchedDuplicateRelationships for each record",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries people of a case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/available-people"
      }
    },
    "prototype.countCaseRelationshipsAvailablePeople": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of of people that match the search criteria and belong to a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts people of a case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/available-people/count"
      }
    },
    "prototype.createCaseRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Created Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates a new instance in relationships of this model.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/relationships"
      }
    },
    "prototype.getCaseRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Relationship of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Find a related item by id for relationships.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/:fk"
      }
    },
    "prototype.updateCaseRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for case"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Updated Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Update a related item by id for relationships.",
      "http": {
        "verb": "put",
        "path": "/cases/:nk/relationships/:fk"
      }
    },
    "prototype.deleteCaseRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for case"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "object",
          "root": true,
          "required": true
        }
      ],
      "description": "Delete a related item by id for relationships.",
      "http": {
        "verb": "del",
        "path": "/cases/:nk/relationships/:fk"
      }
    },
    "prototype.countCaseRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships of a case",
          "required": true
        }
      ],
      "description": "Counts relationships of case.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/count"
      }
    },
    "prototype.findContactRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "Relationships of a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationships of contacts.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships"
      }
    },
    "prototype.getContactRelationshipsAvailablePeople": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "List of people that match the search criteria and belong to a contact. Includes matchedDuplicateRelationships for each record",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries people of a contact",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/available-people"
      }
    },
    "prototype.countContactRelationshipsAvailablePeople": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of of people that match the search criteria and belong to a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts people of a contact",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/available-people/count"
      }
    },
    "prototype.createContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Created Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates a new instance in relationships of this model.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/relationships"
      }
    },
    "prototype.getContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Relationship of a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Find a related item by id for relationships.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/:fk"
      }
    },
    "prototype.updateContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Updated Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Update a related item by id for relationships.",
      "http": {
        "verb": "put",
        "path": "/contacts/:nk/relationships/:fk"
      }
    },
    "prototype.deleteContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "object",
          "root": true,
          "required": true
        }
      ],
      "description": "Delete a related item by id for relationships.",
      "http": {
        "verb": "del",
        "path": "/contacts/:nk/relationships/:fk"
      }
    },
    "prototype.countContactRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships of a contact",
          "required": true
        }
      ],
      "description": "Counts relationships of contact.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/count"
      }
    },
    "prototype.findEventRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "Relationships of a event",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationships of event.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships"
      }
    },
    "prototype.getEventRelationshipsAvailablePeople": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "List of people that match the search criteria and belong to a event. Includes matchedDuplicateRelationships for each record",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries people of a event",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/available-people"
      }
    },
    "prototype.countEventRelationshipsAvailablePeople": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of of people that match the search criteria and belong to a event",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts people of a event",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/available-people/count"
      }
    },
    "prototype.createEventRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Created Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates a new instance in relationships of this model.",
      "http": {
        "verb": "post",
        "path": "/events/:nk/relationships"
      }
    },
    "prototype.getEventRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Relationship of a event",
          "root": true,
          "required": true
        }
      ],
      "description": "Find a related item by id for relationships.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/:fk"
      }
    },
    "prototype.updateEventRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for event"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Updated Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Update a related item by id for relationships.",
      "http": {
        "verb": "put",
        "path": "/events/:nk/relationships/:fk"
      }
    },
    "prototype.deleteEventRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for event"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "object",
          "root": true,
          "required": true
        }
      ],
      "description": "Delete a related item by id for relationships.",
      "http": {
        "verb": "del",
        "path": "/events/:nk/relationships/:fk"
      }
    },
    "prototype.countEventRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships of a event",
          "required": true
        }
      ],
      "description": "Counts relationships of event.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/count"
      }
    },
    "prototype.convertContactToCase": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "body",
          "type": "case",
          "http": {
            "source": "body"
          },
          "description": "Case specific properties"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "case",
          "type": "case",
          "description": "Case resulted from the conversion",
          "required": true,
          "root": true
        }
      ],
      "description": "Converts contact to case.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/convert-to-case"
      }
    },
    "prototype.convertCaseToContact": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "contact",
          "type": "contact",
          "description": "Contact resulted from the conversion",
          "required": true,
          "root": true
        }
      ],
      "description": "Converts case to contact.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/convert-to-contact"
      }
    },
    "prototype.getLocationsHierarchicalList": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'includeChildren' boolean on the first level in 'where'"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "locations",
          "type": [
            {
              "type": {
                "location": "location",
                "children": [
                  {
                    "type": {
                      "location": "location",
                      "children": []
                    }
                  }
                ]
              }
            }
          ],
          "root": true,
          "required": true
        }
      ],
      "description": "Get hierarchical list of locations for an outbreak.",
      "http": {
        "verb": "get",
        "path": "/locations/hierarchical"
      }
    },
    "prototype.restoreCase": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "case",
          "type": "case",
          "description": "Case",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted case.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/restore"
      }
    },
    "prototype.restoreContact": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "contact",
          "type": "contact",
          "description": "Contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted contact.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/restore"
      }
    },
    "prototype.restoreEvent": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "event",
          "type": "event",
          "description": "Event",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted event.",
      "http": {
        "verb": "post",
        "path": "/events/:nk/restore"
      }
    },
    "prototype.generateCaseVisualId": {
      "accepts": [
        {
          "arg": "visualIdMask",
          "type": "string",
          "required": true,
          "description": "Visual ID mask partially resolved (except for the sequence no.)"
        },
        {
          "arg": "personId",
          "type": "string",
          "description": "Case ID for validating existing visual ID (optional)"
        }
      ],
      "returns": [
        {
          "arg": "visualId",
          "type": "string",
          "description": "Visual ID",
          "root": true,
          "required": true
        }
      ],
      "description": "Generates the next (available) visual ID based on the outbreak mask.",
      "http": {
        "verb": "post",
        "path": "/cases/generate-visual-id"
      }
    },
    "prototype.generateContactVisualId": {
      "accepts": [
        {
          "arg": "visualIdMask",
          "type": "string",
          "required": true,
          "description": "Visual ID mask partially resolved (except for the sequence no.)"
        },
        {
          "arg": "personId",
          "type": "string",
          "description": "Contact ID for validating existing visual ID (optional)"
        }
      ],
      "returns": [
        {
          "arg": "visualId",
          "type": "string",
          "description": "Visual ID",
          "root": true,
          "required": true
        }
      ],
      "description": "Generates the next (available) visual ID based on the outbreak mask.",
      "http": {
        "verb": "post",
        "path": "/contacts/generate-visual-id"
      }
    },
    "prototype.filteredCountContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case', 'where.followUp' MongoDB compatible queries. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of contacts that pass the filter",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts the contacts of an outbreak",
      "http": [
        {
          "verb": "get",
          "path": "/contacts/filtered-count"
        },
        {
          "verb": "post",
          "path": "/contacts/filtered-count"
        }
      ]
    },
    "prototype.filteredCountEvents": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: this request also accepts a `noRelationships` flag on the first level of `where`. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of events that pass the filter",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts the cases that pass a filter (which can now accept relations)",
      "http": {
        "verb": "get",
        "path": "/events/filtered-count"
      }
    },
    "prototype.exportFilteredCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, limit, where.useQuestionVariable, where.useDbColumns and where.dontTranslateValues - must be a JSON-encoded string ({\"something\":\"value\"}). Param 'where.useQuestionVariable' is used to display question variables as column headers. Params 'where.useDbColumns' and 'where.dontTranslateValues' are used to display db properties and values instead of label translations (useful for scripts since translation can change). A zip file will be provided in case number of records exceed file type limits (e.g. xls (biff8) has a limit of 65536 rows). Also, if number of columns exceed file limits they will be split into multiple sheets per file (e.g. xls (biff8) has a limit of 255 columns)."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "fieldsGroupList",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields groups will be included in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "exportLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Export filtered list of cases",
      "http": {
        "verb": "get",
        "path": "/cases/export"
      }
    },
    "prototype.exportFilteredEvents": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, limit, where.useDbColumns and where.dontTranslateValues - must be a JSON-encoded string ({\"something\":\"value\"}). Params 'where.useDbColumns' and 'where.dontTranslateValues' are used to display db properties and values instead of label translations (useful for scripts since translation can change). A zip file will be provided in case number of records exceed file type limits (e.g. xls (biff8) has a limit of 65536 rows). Also, if number of columns exceed file limits they will be split into multiple sheets per file (e.g. xls (biff8) has a limit of 255 columns)."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "fieldsGroupList",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields groups will be included in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "exportLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Export filtered list of events",
      "http": {
        "verb": "get",
        "path": "/events/export"
      }
    },
    "prototype.getBarsTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Only filter.where is supported. Defining fields, include, order, offset and limit aren't supported"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": {
        "arg": "data",
        "type": {
          "personsMap": {
            "type": {
              "uidPerson": {
                "type": {
                  "id": {
                    "type": "string",
                    "description": "Case / Event UID"
                  },
                  "visualId": {
                    "type": "string",
                    "description": "Case visual ID"
                  },
                  "type": {
                    "type": "string",
                    "description": "LNG_REFERENCE_DATA_CATEGORY_PERSON_TYPE_CASE / LNG_REFERENCE_DATA_CATEGORY_PERSON_TYPE_EVENT"
                  },
                  "firstName": {
                    "type": "string",
                    "description": "Case firstName / Event name"
                  },
                  "lastName": {
                    "type": "string",
                    "description": "Case lastName"
                  },
                  "date": {
                    "type": "date",
                    "description": "Case dateOfOnset / Event date"
                  },
                  "outcomeId": {
                    "type": "string",
                    "description": "Outcome id"
                  },
                  "dateOfOutcome": {
                    "type": "date",
                    "description": "Outcome date"
                  },
                  "safeBurial": {
                    "type": "boolean",
                    "description": "Burial properly safe?"
                  },
                  "dateOfBurial": {
                    "type": "date",
                    "description": "Burial date"
                  },
                  "firstGraphDate": {
                    "type": "date",
                    "description": "Min graph date for this case / event"
                  },
                  "addresses": [
                    {
                      "type": "address",
                      "description": "Case addresses ( sorted by date asc, current address should be last since it doesn't have a date ) / Event address as an array with one address"
                    }
                  ],
                  "dateRanges": [
                    {
                      "type": {
                        "startDate": {
                          "type": "date"
                        },
                        "endDate": {
                          "type": "date"
                        },
                        "typeId": {
                          "type": "string",
                          "description": "Date type ( isolation / hospitalization ... )"
                        },
                        "locationId": {
                          "type": "string",
                          "description": "Date location UID"
                        },
                        "centerName": {
                          "type": "string",
                          "description": "Treatment center name"
                        }
                      }
                    }
                  ],
                  "centerNames": [
                    "string"
                  ],
                  "labResults": [
                    {
                      "type": {
                        "dateOfResult": {
                          "type": "date"
                        },
                        "dateSampleTaken": {
                          "type": "date"
                        },
                        "testType": {
                          "type": "string"
                        },
                        "result": {
                          "type": "string"
                        }
                      }
                    }
                  ],
                  "lastGraphDate": {
                    "type": "date",
                    "description": "Most recent date between any type dates, lab results dateOfResult and dateOfOnset / event date"
                  }
                }
              }
            }
          },
          "personsOrder": [
            "string"
          ],
          "relationships": {
            "type": {
              "uidSourcePerson": [
                {
                  "type": "string",
                  "description": "Target case / event UID"
                }
              ]
            }
          },
          "minGraphDate": {
            "type": "date",
            "description": "Oldest case date of onset / event date => min(case.dateOfOnset, event.date)"
          },
          "maxGraphDate": {
            "type": "date",
            "description": "Most recent 'lastGraphDate' => max(lastGraphDate)"
          }
        },
        "root": true,
        "required": true
      },
      "description": "Bars graph data",
      "http": {
        "verb": "get",
        "path": "/cases/bars-transmission-chains"
      }
    },
    "prototype.exportFilteredRelationships": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, limit, where.useDbColumns and where.dontTranslateValues - must be a JSON-encoded string ({\"something\":\"value\"}). Supports 'where.person' & 'where.followUp' MongoDB compatible queries. If you include both person & followUp conditions, then and AND will be applied between them. Params 'where.useDbColumns' and 'where.dontTranslateValues' are used to display db properties and values instead of label translations (useful for scripts since translation can change). A zip file will be provided in case number of records exceed file type limits (e.g. xls (biff8) has a limit of 65536 rows). Also, if number of columns exceed file limits they will be split into multiple sheets per file (e.g. xls (biff8) has a limit of 255 columns)."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "fieldsGroupList",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields groups will be included in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "exportLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Export filtered list of relationships",
      "http": {
        "verb": "get",
        "path": "/relationships/export"
      }
    },
    "prototype.restoreContactFollowUp": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for followUps"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "followUp",
          "type": [
            "followUp"
          ],
          "description": "Follow Up",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted follow-up.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/follow-ups/:fk/restore"
      }
    },
    "prototype.generateFollowups": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "generateFollowup",
          "description": "Follow up required period start/end dates and targeted optional flag.",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "response",
          "type": {
            "count": {
              "type": "number"
            }
          },
          "description": "Number of generated follow ups",
          "root": true,
          "required": true
        }
      ],
      "description": "Generate a list of follow-ups",
      "http": {
        "verb": "post",
        "path": "/generate-followups"
      }
    },
    "prototype.countIndependentTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). This accepts a 'where.person', 'where.chainIncludesPerson', 'where.endDate' (used to provide a snapshot of chains until the specified end date), where.includeContacts (default false) queries."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "chains",
          "type": {
            "chains": [
              {
                "type": {
                  "length": {
                    "type": "number",
                    "description": "Number of chain links"
                  },
                  "size": {
                    "type": "number",
                    "description": "Number of chain nodes"
                  },
                  "active": "boolean"
                }
              }
            ],
            "length": "number",
            "activeChainsCount": "number"
          },
          "description": "Number of transmission chains and the length of each chain",
          "required": true,
          "root": true
        }
      ],
      "description": "Count the number of independent transmission chains",
      "http": {
        "verb": "get",
        "path": "/relationships/independent-transmission-chains/filtered-count"
      }
    },
    "prototype.getIndependentTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'where.active' boolean, 'where.size' number, 'where.person', 'where.chainIncludesPerson', 'where.endDate' (used to provide a snapshot of chains until the specified end date), where.includeContacts (default false) queries."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "chains",
          "type": {
            "nodes": {
              "type": {
                "<personId>": {
                  "type": "person"
                }
              }
            },
            "edges": {
              "type": {
                "<relationshipId>": {
                  "type": "relationship"
                }
              }
            },
            "transmissionChains": {
              "type": {
                "chains": [
                  {
                    "type": {
                      "chain": [
                        "string"
                      ],
                      "period": {
                        "type": {
                          "startDate": "date",
                          "endDate": "date",
                          "duration": {
                            "type": "number",
                            "description": "Transmission chain duration in days"
                          }
                        }
                      },
                      "active": "boolean"
                    }
                  }
                ],
                "length": {
                  "type": "number",
                  "description": "Number of chain links"
                },
                "size": {
                  "type": "number",
                  "description": "Number of chain nodes"
                }
              }
            }
          },
          "description": "Independent transmission chains",
          "required": true,
          "root": true
        }
      ],
      "description": "Get independent transmission chains",
      "http": {
        "verb": "get",
        "path": "/relationships/independent-transmission-chains"
      }
    },
    "prototype.calculateIndependentTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'where.active' boolean, 'where.size' number, 'where.person', 'where.chainIncludesPerson', 'where.endDate' (used to provide a snapshot of chains until the specified end date), where.includeContacts (default false) queries."
        },
        {
          "arg": "body",
          "type": "object",
          "model": "transmissionChainCalculate",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "transmissionChainId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Calculate independent transmission chains",
      "http": {
        "verb": "post",
        "path": "/relationships/calculate-independent-transmission-chains"
      }
    },
    "prototype.getCalculatedIndependentTransmissionChains": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "ID of the transmission chain"
        },
        {
          "arg": "res",
          "type": "object",
          "http": {
            "source": "res"
          }
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "chains",
          "type": {
            "nodes": {
              "type": {
                "<personId>": {
                  "type": "person"
                }
              }
            },
            "edges": {
              "type": {
                "<relationshipId>": {
                  "type": "relationship"
                }
              }
            },
            "transmissionChains": {
              "type": {
                "chains": [
                  {
                    "type": {
                      "chain": [
                        "string"
                      ],
                      "period": {
                        "type": {
                          "startDate": "date",
                          "endDate": "date",
                          "duration": {
                            "type": "number",
                            "description": "Transmission chain duration in days"
                          }
                        }
                      },
                      "active": "boolean"
                    }
                  }
                ],
                "length": {
                  "type": "number",
                  "description": "Number of chain links"
                },
                "size": {
                  "type": "number",
                  "description": "Number of chain nodes"
                }
              }
            }
          },
          "description": "Independent transmission chains",
          "required": true,
          "root": true
        }
      ],
      "description": "Get already calculated independent transmission chains",
      "http": {
        "verb": "get",
        "path": "/transmission-chains/:fk/result"
      }
    },
    "prototype.countContactsSeen": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "contactsSeenCount": "number",
            "contactIDs": {
              "type": [
                "string"
              ],
              "description": "Array with IDs of contacts that are seen",
              "required": true
            },
            "teams": [
              {
                "type": {
                  "id": "string",
                  "contactsSeenCount": "number",
                  "contactIDs": {
                    "type": [
                      "string"
                    ],
                    "description": "Array with IDs of contacts that are seen",
                    "required": true
                  }
                }
              }
            ]
          },
          "description": "Object containing counters for seen contacts",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of seen contacts as well as per team",
      "http": {
        "verb": "get",
        "path": "/follow-ups/contacts-seen/count"
      }
    },
    "prototype.countContactsLostToFollowup": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "contactsLostToFollowupCount": "number",
            "contactIDs": {
              "type": [
                "string"
              ],
              "description": "Array with IDs of contacts that are lost to follow-up",
              "required": true
            },
            "teams": [
              {
                "type": {
                  "id": "string",
                  "contactsLostToFollowupCount": "number",
                  "contactIDs": {
                    "type": [
                      "string"
                    ],
                    "description": "Array with IDs of contacts that are lost to follow-up",
                    "required": true
                  }
                }
              }
            ]
          },
          "description": "Object containing counters for contacts lost to follow-up",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of contacts lost to follow-up as well as per team",
      "http": {
        "verb": "get",
        "path": "/follow-ups/contacts-lost-to-follow-up/count"
      }
    },
    "prototype.countCasesWithLessThanXContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noLessContacts' number on the first level in 'where'"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "casesCount": {
              "type": "number",
              "description": "Number of cases with less than X contacts",
              "required": true
            },
            "caseIDs": {
              "type": [
                "string"
              ],
              "description": "Array with IDs of cases with less than X contacts",
              "required": true
            },
            "cases": [
              {
                "type": {
                  "id": "string",
                  "contactsCount": {
                    "type": "number",
                    "description": "Number of contacts for case",
                    "required": true
                  },
                  "contactIDs": [
                    "string"
                  ]
                },
                "description": "Array with information for the cases with less than X contacts"
              }
            ]
          },
          "required": true,
          "root": true
        }
      ],
      "description": "Count the number of cases with less than X contacts; Also return the case IDs",
      "http": {
        "verb": "get",
        "path": "/relationships/cases-with-less-than-x-contacts/count"
      }
    },
    "prototype.countNewCasesInKnownTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noDaysInChains' number on the first level in 'where'"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "newCases": "number",
            "total": "number",
            "caseIds": [
              "string"
            ]
          },
          "description": "Retrieve number of new cases in known transmission chains",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of new cases vs total number of cases in known transmission chains",
      "http": {
        "verb": "get",
        "path": "/relationships/new-cases-in-transmission-chains/count"
      }
    },
    "prototype.longPeriodsBetweenDatesOfOnsetInTransmissionChains": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "List of relationships that links cases with long periods between the dates of onset (includes people relation and the time difference in differenceBetweenDatesOfOnset param)",
          "root": true,
          "required": true
        }
      ],
      "description": "Get a list of relationships that links cases with long periods between the dates of onset",
      "http": {
        "verb": "get",
        "path": "/relationships/long-periods-between-dates-of-onset-in-transmission-chains"
      }
    },
    "prototype.buildNewChainsFromRegisteredContactsWhoBecameCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "chains",
          "type": {
            "nodes": {
              "type": {
                "<personId>": {
                  "type": "person"
                }
              }
            },
            "edges": {
              "type": {
                "<relationshipId>": {
                  "type": "relationship"
                }
              }
            },
            "transmissionChains": {
              "type": {
                "chains": [
                  {
                    "type": {
                      "chain": [
                        "string"
                      ],
                      "period": {
                        "type": {
                          "startDate": "date",
                          "endDate": "date",
                          "duration": {
                            "type": "number",
                            "description": "Transmission chain duration in days"
                          }
                        }
                      },
                      "active": "boolean"
                    }
                  }
                ],
                "length": "number"
              }
            }
          },
          "description": "New transmission chains",
          "required": true,
          "root": true
        }
      ],
      "description": "Build new transmission chains from registered contacts who became cases",
      "http": {
        "verb": "get",
        "path": "/relationships/new-transmission-chains-from-registered-contacts-who-became-cases"
      }
    },
    "prototype.countNewChainsFromRegisteredContactsWhoBecameCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "chains",
          "type": {
            "chains": [
              {
                "type": {
                  "length": "number",
                  "active": "boolean"
                }
              }
            ],
            "length": "number",
            "activeChainsCount": "number"
          },
          "description": "Number of transmission chains and the length of each chain",
          "required": true,
          "root": true
        }
      ],
      "description": "Count new transmission chains from registered contacts who became cases",
      "http": {
        "verb": "get",
        "path": "/relationships/new-transmission-chains-from-registered-contacts-who-became-cases/filtered-count"
      }
    },
    "prototype.countCasesContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "casesCount": {
              "type": "number",
              "description": "Total number of cases",
              "required": true
            },
            "contactsCount": {
              "type": "number",
              "description": "Total number of contacts related to cases; Note there might be other contacts related to events.",
              "required": true
            },
            "meanNoContactsPerCase": {
              "type": "number",
              "description": "Mean Number of contacts per case",
              "required": true
            },
            "medianNoContactsPerCase": {
              "type": "number",
              "description": "Median Number of contacts per case",
              "required": true
            },
            "cases": [
              {
                "type": {
                  "id": "string",
                  "contactsCount": {
                    "type": "number",
                    "description": "Number of contacts for case",
                    "required": true
                  },
                  "contactIDs": [
                    "string"
                  ]
                }
              }
            ]
          },
          "description": "Object containing counters for contacts per case",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of contacts for each case; Additionally calculate mean/median",
      "http": {
        "verb": "get",
        "path": "/relationships/contacts-per-case/count"
      }
    },
    "prototype.findSecondaryCasesWithDateOfOnsetBeforePrimaryCase": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "results",
          "type": [
            {
              "type": {
                "primaryCase": "case",
                "secondaryCase": "case",
                "relationship": "relationship"
              }
            }
          ],
          "description": "List of secondary cases that have date of onset before the date of onset of primary cases",
          "root": true,
          "required": true
        }
      ],
      "description": "Get a list of secondary cases that have date of onset before the date of onset of primary cases",
      "http": {
        "verb": "get",
        "path": "/relationships/secondary-cases-with-date-of-onset-before-primary-case"
      }
    },
    "prototype.setTargetAndSourceForRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "relationship id"
        },
        {
          "arg": "body",
          "required": true,
          "type": "object",
          "model": "relationshipSourceTarget",
          "http": {
            "source": "body"
          },
          "description": "Source and Target values"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Updated relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Change source and target of a relationship ( needs write case / contact permission )",
      "http": {
        "verb": "post",
        "path": "/relationships/:nk/replace-source-and-target"
      }
    },
    "prototype.countNewCasesInThePreviousXDaysDetectedAmongKnownContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noDaysAmongContacts' number on the first level in 'where'"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "newCasesCount": {
              "type": "number",
              "description": "Number of new cases in the previous X days",
              "required": true
            },
            "newCasesAmongKnownContactsCount": {
              "type": "number",
              "description": "Number of new cases in the previous X days detected among known contacts",
              "required": true
            },
            "newCasesAmongKnownContactsIDs": [
              "string"
            ]
          },
          "description": "Object containing counters for new cases in the previous X days",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of new cases in the previous X days",
      "http": {
        "verb": "get",
        "path": "/cases/new-among-known-contacts/count"
      }
    },
    "prototype.countContactsNotSeenInXDays": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'noDaysNotSeen' number on the first level in 'where'"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "contactsCount": {
              "type": "number",
              "description": "Number of contacts not seen in the past X days",
              "required": true
            },
            "contactIDs": [
              "string"
            ]
          },
          "description": "Object containing counters for contacts not seen in the past X days",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the number of contacts not seen in the past X days",
      "http": {
        "verb": "get",
        "path": "/follow-ups/contacts-not-seen/count"
      }
    },
    "prototype.countContactsWithSuccessfulFollowups": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "totalContactsWithFollowupsCount": "number",
            "contactsWithSuccessfulFollowupsCount": "number",
            "teams": {
              "type": [
                {
                  "type": {
                    "id": "string",
                    "totalContactsWithFollowupsCount": "number",
                    "contactsWithSuccessfulFollowupsCount": "number",
                    "followedUpContactsIDs": [
                      "string"
                    ],
                    "missedContactsIDs": [
                      "string"
                    ]
                  }
                }
              ]
            },
            "contacts": {
              "type": [
                {
                  "type": {
                    "id": "string",
                    "totalFollowupsCount": "number",
                    "successfulFollowupsCount": "number"
                  }
                }
              ]
            }
          },
          "description": "Object containing counters for contacts with follow-ups and contacts with successful follow-ups",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of contacts with follow-ups and contacts with successful follow-ups",
      "http": {
        "verb": "get",
        "path": "/follow-ups/contacts-with-successful-follow-ups/count"
      }
    },
    "prototype.countFollowUpsPerTeamPerDay": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "totalFollowupsCount": "number",
            "successfulFollowupsCount": "number",
            "teams": {
              "type": [
                {
                  "type": {
                    "id": "string",
                    "dates": {
                      "type": [
                        {
                          "type": {
                            "date": "date",
                            "totalFollowupsCount": "number",
                            "successfulFollowupsCount": "number",
                            "contactsIDs": [
                              "string"
                            ]
                          }
                        }
                      ]
                    }
                  }
                }
              ]
            }
          },
          "description": "Object containing counters for follow-ups per day",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of followups and successful followups",
      "http": {
        "verb": "get",
        "path": "/follow-ups/per-team-per-day/count"
      }
    },
    "prototype.countFollowUpsPerUserPerDay": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "totalFollowupsCount": "number",
            "successfulFollowupsCount": "number",
            "users": {
              "type": [
                {
                  "type": {
                    "id": "string",
                    "dates": {
                      "type": [
                        {
                          "type": {
                            "date": "date",
                            "totalFollowupsCount": "number",
                            "successfulFollowupsCount": "number",
                            "contactsIDs": [
                              "string"
                            ]
                          }
                        }
                      ]
                    }
                  }
                }
              ]
            }
          },
          "description": "Object containing counters for follow-ups per day",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of followups and successful followups",
      "http": {
        "verb": "get",
        "path": "/follow-ups/per-user-per-day/count"
      }
    },
    "prototype.mergePeople": {
      "accepts": [
        {
          "arg": "data",
          "model": "mergePeopleProps",
          "type": "object",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "model",
          "type": "object",
          "description": "Case/Contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Merge multiple people of the same type (case/event/contact)",
      "http": {
        "verb": "post",
        "path": "/merge"
      }
    },
    "prototype.listInconsistenciesInKeyDates": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "Array containing contacts/cases where inconsistencies were found between dates. Besides the contact/case properties each entry will also contain an 'inconsistencies' property (array of inconsistencies)",
          "root": true,
          "required": true
        }
      ],
      "description": "List of contacts/cases where inconsistencies were found between dates. Besides the contact/case properties each entry will also contain an 'inconsistencies' property (array of inconsistencies)",
      "http": {
        "verb": "get",
        "path": "/people/inconsistencies-in-key-dates"
      }
    },
    "prototype.importableFileUpload": {
      "accepts": [
        {
          "arg": "req",
          "type": "object",
          "http": {
            "source": "req"
          }
        },
        {
          "arg": "file",
          "type": "file"
        },
        {
          "arg": "model",
          "type": "string"
        },
        {
          "arg": "decryptPassword",
          "type": "string",
          "description": "If provided, the imported file will be decrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "result",
          "type": {
            "id": "string",
            "fileHeaders": [
              "string"
            ],
            "suggestedFieldMapping": {
              "type": {
                "<fileHeader>": {
                  "type": "string",
                  "description": "Model property"
                }
              }
            },
            "modelProperties": {
              "type": {
                "<modelProperty>": [
                  {
                    "type": "string",
                    "description": "Model property label"
                  }
                ]
              }
            },
            "modelPropertyValues": {
              "type": {
                "<modelProperty>": [
                  {
                    "type": "string",
                    "description": "Available values for a model property"
                  }
                ]
              }
            },
            "distinctFileColumnValues": {
              "type": {
                "<fileHeader>": [
                  {
                    "type": "string",
                    "description": "Distinct values for column"
                  }
                ]
              }
            }
          },
          "root": true,
          "required": true
        }
      ],
      "description": "Upload a file and get file headers",
      "http": {
        "verb": "post",
        "path": "/importable-files"
      }
    },
    "prototype.getImportableFileJsonById": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Importable file ID",
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "json",
          "type": [
            "any"
          ],
          "required": true,
          "root": true
        }
      ],
      "description": "Retrieve JSON version of an uploaded file",
      "http": {
        "verb": "get",
        "path": "/importable-files/:id/json"
      }
    },
    "prototype.importImportableCaseLabResultsFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "importLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Import a list of lab results from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/cases/lab-results/import-importable-file-using-map"
      }
    },
    "prototype.exportCaseInvestigationTemplate": {
      "accepts": [
        {
          "arg": "copies",
          "type": "number",
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export pdf containing case investigation template",
      "http": {
        "verb": "get",
        "path": "/cases/export-investigation-template"
      }
    },
    "prototype.contactDossier": {
      "accepts": [
        {
          "arg": "contacts",
          "type": [
            "string"
          ],
          "description": "Array of contacts for which the dossiers will be generated"
        },
        {
          "arg": "data",
          "type": [
            "string"
          ],
          "description": "Array of fields to be anonymized"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export dossier for one or more contacts",
      "http": {
        "verb": "post",
        "ignoreActiveOutbreak": true,
        "path": "/contacts/dossier"
      }
    },
    "prototype.caseDossier": {
      "accepts": [
        {
          "arg": "cases",
          "type": [
            "string"
          ],
          "description": "Array of cases for which the dossiers will be generated"
        },
        {
          "arg": "data",
          "type": [
            "string"
          ],
          "description": "Array of fields to be anonymized"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export dossier for one or more cases",
      "http": {
        "verb": "post",
        "ignoreActiveOutbreak": true,
        "path": "/cases/dossier"
      }
    },
    "prototype.importImportableCasesFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "importLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Import a list of cases from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/cases/import-importable-file-using-map"
      }
    },
    "prototype.importImportableEventsFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "importLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Import a list of events from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/events/import-importable-file-using-map"
      }
    },
    "prototype.importImportableContactsFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "importLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Import a list of contacts from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/contacts/import-importable-file-using-map"
      }
    },
    "prototype.exportFilteredContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, limit, where.useQuestionVariable, where.useDbColumns and where.dontTranslateValues - must be a JSON-encoded string ({\"something\":\"value\"}). Param 'where.useQuestionVariable' is used to display question variables as column headers. Params 'where.useDbColumns' and 'where.dontTranslateValues' are used to display db properties and values instead of label translations (useful for scripts since translation can change). A zip file will be provided in case number of records exceed file type limits (e.g. xls (biff8) has a limit of 65536 rows). Also, if number of columns exceed file limits they will be split into multiple sheets per file (e.g. xls (biff8) has a limit of 255 columns)."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "fieldsGroupList",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields groups will be included in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "exportLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Export filtered list of contacts",
      "http": {
        "verb": "get",
        "path": "/contacts/export"
      }
    },
    "prototype.findPeopleInCluster": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "ID of the cluster"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "List of people in the cluster",
          "required": true,
          "root": true
        }
      ],
      "description": "Find the people inside a cluster",
      "http": {
        "verb": "get",
        "path": "/clusters/:fk/people"
      }
    },
    "prototype.countPeopleInCluster": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "ID of the cluster"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of people in the cluster",
          "required": true
        }
      ],
      "description": "Number the people inside a cluster",
      "http": {
        "verb": "get",
        "path": "/clusters/:fk/people/count"
      }
    },
    "prototype.findFollowUps": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.contact', 'where.case' MongoDB compatible queries, where.timeLastSeen', 'where.weekNumber' queries"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "followUps",
          "type": [
            "followUp"
          ],
          "description": "List of followUps that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries followUps of outbreak.",
      "http": {
        "verb": "get",
        "path": "/followUps"
      }
    },
    "prototype.filteredCountFollowUps": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.contact', 'where.case' MongoDB compatible queries, where.timeLastSeen', 'where.weekNumber' queries. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of follow-ups that pass the filter",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts the follow-ups that pass a filter (which now can accept relations)",
      "http": {
        "verb": "get",
        "path": "/follow-ups/filtered-count"
      }
    },
    "prototype.filteredCountCaseRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships (that pass the filter) of a case",
          "required": true
        }
      ],
      "description": "Counts the relationships that pass a filter (which now can accept relations) of a case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/filteredCount"
      }
    },
    "prototype.filteredCountContactRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships (that pass the filter) of a contact",
          "required": true
        }
      ],
      "description": "Counts the relationships that pass a filter (which now can accept relations) of a case",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/filteredCount"
      }
    },
    "prototype.filteredCountEventRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships (that pass the filter) of an event",
          "required": true
        }
      ],
      "description": "Counts the relationships that pass a filter (which now can accept relations) of a case",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/filtered-count"
      }
    },
    "prototype.exportFilteredFollowups": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, limit, where.useQuestionVariable, where.useDbColumns and where.dontTranslateValues - must be a JSON-encoded string ({\"something\":\"value\"}). Param 'where.useQuestionVariable' is used to display question variables as column headers. Params 'where.useDbColumns' and 'where.dontTranslateValues' are used to display db properties and values instead of label translations (useful for scripts since translation can change). A zip file will be provided in case number of records exceed file type limits (e.g. xls (biff8) has a limit of 65536 rows). Also, if number of columns exceed file limits they will be split into multiple sheets per file (e.g. xls (biff8) has a limit of 255 columns)."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "fieldsGroupList",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields groups will be included in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "exportLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Export filtered list of follow ups",
      "http": {
        "verb": "get",
        "path": "/follow-ups/export"
      }
    },
    "prototype.exportExistingEmptyCaseInvestigation": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export an empty case investigation for an existing case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/export-empty-case-investigation"
      }
    },
    "prototype.findPossiblePersonDuplicates": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note that filter.where needs to be a valid MongoDB where condition, not loopback, because the query is ran directly on MongoDB for performance reasons."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "duplicates",
          "type": {
            "peopleMap": {
              "type": {
                "<personId>": "person"
              }
            },
            "groups": [
              {
                "type": {
                  "duplicateKey": {
                    "type": "string",
                    "description": "The key/rule (name, phoneNumber, documents) that was matched by all the records in the group"
                  },
                  "indexKey": {
                    "type": "string",
                    "description": "They (constructed) key that was matched by all the records in the group"
                  },
                  "peopleIds": [
                    "string"
                  ]
                }
              }
            ]
          },
          "description": "Possible duplicate people groups",
          "root": true,
          "required": true
        }
      ],
      "description": "Find the possible duplicate people groups",
      "http": {
        "verb": "get",
        "path": "/people/possible-duplicates"
      }
    },
    "prototype.countPossiblePersonDuplicates": {
      "accepts": [
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances. Note that this needs to be a valid MongoDB where condition, not loopback, because the query is ran directly on MongoDB for performance reasons."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of possible duplicate people groups",
          "required": true
        }
      ],
      "description": "Count the number of possible duplicate people groups",
      "http": {
        "verb": "get",
        "path": "/people/possible-duplicates/count"
      }
    },
    "prototype.createCaseMultipleContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "data",
          "type": [
            "contactAndRelationship"
          ],
          "description": "Array containing pairs for contact + relationship",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "createResponse",
          "type": [
            "contactAndRelationship"
          ],
          "description": "Array of responses for the create actions",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates multiple contacts for a case.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/contacts"
      }
    },
    "prototype.createEventMultipleContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "data",
          "type": [
            "contactAndRelationship"
          ],
          "description": "Array containing pairs for contact + relationship",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "createResponse",
          "type": [
            "contactAndRelationship"
          ],
          "description": "Array of responses for the create actions",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates multiple contacts for a event.",
      "http": {
        "verb": "post",
        "path": "/events/:nk/contacts"
      }
    },
    "prototype.filteredCountLabResults": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case' MongoDB compatible queries. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of lab results that pass the filter",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts the lab results that pass a filter",
      "http": {
        "verb": "get",
        "path": "/lab-results/filtered-count"
      }
    },
    "prototype.filteredCountCaseLabResults": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case' MongoDB compatible queries. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of lab results that pass the filter",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts the lab results that pass a filter",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/lab-results/filtered-count"
      }
    },
    "prototype.filteredCountContactLabResults": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case' MongoDB compatible queries. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of lab results that pass the filter",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts the lab results that pass a filter",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/lab-results/filtered-count"
      }
    },
    "prototype.findLabResultsAggregate": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, order, skip, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'case.field' conditions, case being another property from lab result"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "labResults",
          "type": [
            "labResult"
          ],
          "description": "List of labResults that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries labResults of outbreak.",
      "http": {
        "verb": "get",
        "path": "/lab-results/aggregate"
      }
    },
    "prototype.filteredCountLabResultsAggregate": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, order, skip, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'case.field' MongoDB compatible queries. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of lab results that pass the filter",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts the lab results that pass a filter",
      "http": {
        "verb": "get",
        "path": "/lab-results/aggregate-filtered-count"
      }
    },
    "restoreOutbreak": {
      "accepts": [
        {
          "arg": "id",
          "type": "string",
          "description": "Outbreak ID"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "outbreak",
          "type": "outbreak",
          "description": "Outbreak",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted outbreak.",
      "http": {
        "verb": "post",
        "path": "/:id/restore"
      }
    },
    "prototype.findCaseRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "exposures",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship exposures of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship exposures of case.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/exposures"
      }
    },
    "prototype.countCaseRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship exposures (that pass the filter) of a case",
          "required": true
        }
      ],
      "description": "Counts the relationship exposures that pass a filter of a case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/exposures/filtered-count"
      }
    },
    "prototype.findCaseRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship contacts of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship contacts of case.",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/contacts"
      }
    },
    "prototype.countCaseRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship contacts (that pass the filter) of a case",
          "required": true
        }
      ],
      "description": "Counts the relationship contacts that pass a filter of a case",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/relationships/contacts/filtered-count"
      }
    },
    "prototype.findContactRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "exposures",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship exposures of a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship exposures of contact.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/exposures"
      }
    },
    "prototype.countContactRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship exposures (that pass the filter) of a contact",
          "required": true
        }
      ],
      "description": "Counts the relationship exposures that pass a filter of a contact",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/exposures/filtered-count"
      }
    },
    "prototype.findContactRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship contacts of a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship contacts of contacts.",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/contacts"
      }
    },
    "prototype.countContactRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship contacts (that pass the filter) of a contact",
          "required": true
        }
      ],
      "description": "Counts the relationship contacts that pass a filter of a contact",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/relationships/contacts/filtered-count"
      }
    },
    "prototype.findEventRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "exposures",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship exposures of a event",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship exposures of event.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/exposures"
      }
    },
    "prototype.countEventRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship exposures (that pass the filter) of a event",
          "required": true
        }
      ],
      "description": "Counts the relationship exposures that pass a filter of a event",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/exposures/filtered-count"
      }
    },
    "prototype.findEventRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship contacts of a event",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship contacts of event.",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/contacts"
      }
    },
    "prototype.countEventRelationshipContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for events"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship contacts (that pass the filter) of a event",
          "required": true
        }
      ],
      "description": "Counts the relationship contacts that pass a filter of a event",
      "http": {
        "verb": "get",
        "path": "/events/:nk/relationships/contacts/filtered-count"
      }
    },
    "prototype.countCasesPerClassification": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: it supports same filters as GET /outbreak/:id/cases"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "classification": {
              "type": {
                "<caseClassification>": {
                  "type": {
                    "count": "number"
                  }
                }
              }
            },
            "count": "number"
          },
          "description": "Number of cases grouped by case classification",
          "required": true,
          "root": true
        }
      ],
      "description": "Counts the number of cases grouped by case classification",
      "http": {
        "verb": "get",
        "path": "/cases/per-classification/count"
      }
    },
    "prototype.countCasesHospitalized": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Supports filter.flags.date to specify the date taken in account the hospitalization & isolation numbers."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "hospitalized": "number",
            "isolated": "number",
            "notHospitalized": "number",
            "total": "number"
          },
          "description": "Number of cases hospitalized and isolated",
          "required": true,
          "root": true
        }
      ],
      "description": "Counts the number of cases hospitalized and isolated",
      "http": {
        "verb": "get",
        "path": "/cases/hospitalized/count"
      }
    },
    "prototype.countContactsPerRiskLevel": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: it supports same filters as GET /outbreak/:id/contacts"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "riskLevel": {
              "type": {
                "<riskLevel>": {
                  "type": {
                    "count": "number"
                  }
                }
              }
            },
            "count": "number"
          },
          "description": "Number of contacts grouped by case risk level",
          "required": true,
          "root": true
        }
      ],
      "description": "Counts the number of contacts grouped by case risk level",
      "http": {
        "verb": "get",
        "path": "/contacts/per-risk-level/count"
      }
    },
    "prototype.countCasesStratifiedByClassificationOverTime": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: this request also accepts 'periodType': enum [day, week, month], 'endDate' on the first level in 'where'"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "<periodIndex>": {
              "type": {
                "start": "date",
                "end": "date",
                "classification": {
                  "type": {
                    "{caseClassification}": {
                      "type": "number",
                      "description": "Number of cases in the classification for the period"
                    }
                  }
                },
                "total": {
                  "type": "number",
                  "description": "Total number of cases for the period"
                }
              }
            }
          },
          "description": "Number of cases stratified by classification over time",
          "required": true,
          "root": true
        }
      ],
      "description": "Count cases stratified by classification over time",
      "http": {
        "verb": "get",
        "path": "/cases/classification-over-time/count"
      }
    },
    "prototype.countCasesStratifiedByOutcomeOverTime": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: this request also accepts 'periodType': enum [day, week, month], 'endDate' on the first level in 'where'"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "<periodIndex>": {
              "type": {
                "start": "date",
                "end": "date",
                "outcome": {
                  "type": {
                    "{caseOutcome}": {
                      "type": "number",
                      "description": "Number of cases for the outcome for the period"
                    }
                  }
                },
                "total": {
                  "type": "number",
                  "description": "Total number of cases for the period"
                }
              }
            }
          },
          "description": "Number of cases stratified by outcome over time",
          "required": true,
          "root": true
        }
      ],
      "description": "Count cases stratified by outcome over time",
      "http": {
        "verb": "get",
        "path": "/cases/outcome-over-time/count"
      }
    },
    "prototype.countCasesStratifiedByClassificationOverReportingTime": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: this request also accepts 'periodType': enum [day, week, month], 'endDate' on the first level in 'where'"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "<periodIndex>": {
              "type": {
                "start": "date",
                "end": "date",
                "classification": {
                  "type": {
                    "{caseClassification}": {
                      "type": "number",
                      "description": "Number of cases in the classification for the reporting period"
                    }
                  }
                },
                "total": {
                  "type": "number",
                  "description": "Total number of cases for the reporting period"
                }
              }
            }
          },
          "description": "Number of cases stratified by classification over reporting time",
          "required": true,
          "root": true
        }
      ],
      "description": "Count cases stratified by classification over reporting time",
      "http": {
        "verb": "get",
        "path": "/cases/classification-over-reporting-time/count"
      }
    },
    "prototype.countFollowUpsByTeam": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "team": {
              "type": {
                "<teamId>": {
                  "type": {
                    "team": "team",
                    "followUpIds": [
                      "string"
                    ],
                    "count": "number"
                  }
                }
              }
            },
            "count": {
              "type": "number",
              "description": "Total number of follow-ups"
            }
          },
          "description": "Number of follow-ups grouped by team",
          "required": true,
          "root": true
        }
      ],
      "description": "Count follow-ups grouped by team",
      "http": {
        "verb": "get",
        "path": "/follow-ups/per-team/count"
      }
    },
    "prototype.attachmentUpload": {
      "accepts": [
        {
          "arg": "req",
          "type": "object",
          "http": {
            "source": "req"
          }
        },
        {
          "arg": "attachmentId",
          "type": "string"
        },
        {
          "arg": "name",
          "type": "string"
        },
        {
          "arg": "file",
          "type": "file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "file",
          "type": "fileAttachment",
          "root": true
        }
      ],
      "description": "Upload a new attachment.",
      "http": {
        "verb": "post",
        "path": "/attachments"
      }
    },
    "prototype.attachmentDownload": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for attachments"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Download an attachment.",
      "http": {
        "verb": "get",
        "path": "/attachments/:fk/download"
      }
    },
    "prototype.findRelationships": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "List of relationships that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationships of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/relationships"
        }
      ]
    },
    "prototype.countRelationships": {
      "accepts": [
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships",
          "required": true
        }
      ],
      "description": "Counts relationships of outbreak.",
      "http": {
        "verb": "get",
        "path": "/relationships/count"
      }
    },
    "prototype.bulkCreateRelationships": {
      "accepts": [
        {
          "arg": "sources",
          "type": [
            "string"
          ],
          "description": "List of people (cases/events) IDs to be used as source of the relationship"
        },
        {
          "arg": "targets",
          "type": [
            "string"
          ],
          "description": "List of people IDs to be used as target of the relationship"
        },
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Common relationship data"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "root": true,
          "required": true,
          "description": "List of created relationships"
        }
      ],
      "description": "Bulk create relationships.",
      "http": {
        "verb": "post",
        "path": "/relationships/bulk"
      }
    },
    "prototype.bulkDeleteRelationships": {
      "accepts": [
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match filter thorough relationships",
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": {
        "arg": "count",
        "type": "integer",
        "required": true,
        "description": "Number of records deleted"
      },
      "description": "Bulk delete relationships.",
      "http": {
        "verb": "delete",
        "path": "/relationships/bulk"
      }
    },
    "prototype.bulkChangeTargetRelationships": {
      "accepts": [
        {
          "arg": "targetId",
          "type": "string",
          "description": "Case / Contact / Event id",
          "required": true
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match filter thorough relationships",
          "required": true
        }
      ],
      "returns": {
        "arg": "count",
        "type": "integer",
        "required": true,
        "description": "Number of records updated"
      },
      "description": "Bulk change target relationships.",
      "http": {
        "verb": "post",
        "path": "/relationships/bulk-change-target"
      }
    },
    "prototype.bulkChangeSourceRelationships": {
      "accepts": [
        {
          "arg": "sourceId",
          "type": "string",
          "description": "Case / Contact / Event id",
          "required": true
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match filter thorough relationships",
          "required": true
        }
      ],
      "returns": {
        "arg": "count",
        "type": "integer",
        "required": true,
        "description": "Number of records updated"
      },
      "description": "Bulk change source relationships.",
      "http": {
        "verb": "post",
        "path": "/relationships/bulk-change-source"
      }
    },
    "prototype.downloadCaseClassificationPerLocationLevelReport": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export a case classification per location report for an outbreak",
      "http": {
        "verb": "get",
        "path": "/cases/per-classification-per-location-level-report/download"
      }
    },
    "prototype.countCasesPerLocationLevel": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "result",
          "type": {
            "locations": [
              {
                "type": {
                  "location": {
                    "type": "location"
                  },
                  "caseIds": {
                    "type": "string"
                  },
                  "casesCount": {
                    "type": "number"
                  }
                }
              }
            ],
            "count": {
              "type": "number"
            }
          },
          "description": "Collection of items with location, cases and numberOfCases properties",
          "root": true,
          "required": true
        }
      ],
      "description": "Return an array of locations and the cases (that pass a filter) assigned to those locations",
      "http": {
        "verb": "get",
        "path": "/cases/per-location-level/count"
      }
    },
    "prototype.downloadContactTracingPerLocationLevelReport": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export a contact tracing per location report for an outbreak",
      "http": {
        "verb": "get",
        "path": "/contacts/per-location-level-tracing-report/download"
      }
    },
    "prototype.getCaseMovement": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for cases"
        }
      ],
      "returns": [
        {
          "arg": "movement",
          "type": [
            "address"
          ],
          "description": "List of addresses with GeoLocations ordered from the oldest one to the most recent",
          "root": true,
          "required": true
        }
      ],
      "description": "Get list of addresses with GeoLocations ordered from the oldest one to the most recent",
      "http": {
        "verb": "get",
        "path": "/cases/:fk/movement"
      }
    },
    "prototype.getContactMovement": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for contacts"
        }
      ],
      "returns": [
        {
          "arg": "movement",
          "type": [
            "address"
          ],
          "description": "List of addresses with GeoLocations ordered from the oldest one to the most recent",
          "root": true,
          "required": true
        }
      ],
      "description": "Get list of addresses with GeoLocations ordered from the oldest one to the most recent",
      "http": {
        "verb": "get",
        "path": "/contacts/:fk/movement"
      }
    },
    "prototype.__get__people": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "List of people that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries people of outbreak.",
      "http": {
        "verb": "get",
        "path": "/people"
      }
    },
    "prototype.countPeople": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})\n. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of records that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts people of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/people/filtered-count"
        }
      ]
    },
    "prototype.findEvents": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). It also supports custom filter option: 'where.countRelations' for count number of exposures/contacts."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "events",
          "type": [
            "event"
          ],
          "description": "List of events that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries events of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/events"
        }
      ]
    },
    "prototype.findCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.relationship', 'where.labResult' MongoDB compatible queries, 'where.noRelationships' query and 'where.countRelations' query."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "cases",
          "type": [
            "case"
          ],
          "description": "List of cases that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries cases of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/cases"
        },
        {
          "verb": "post",
          "path": "/cases/filter"
        }
      ]
    },
    "prototype.filteredCountCases": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.relationship', 'where.labResult' MongoDB compatible queries and 'where.noRelationships' query. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of cases that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts cases of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/cases/filtered-count"
        },
        {
          "verb": "post",
          "path": "/cases/filtered-count"
        }
      ]
    },
    "prototype.findContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case', 'where.followUp' MongoDB compatible queries. It also supports custom filter option: 'where.countRelations' for count number of exposures/contacts."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "contact"
          ],
          "description": "List of contacts that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries contacts of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/contacts"
        },
        {
          "verb": "post",
          "path": "/contacts/filter"
        }
      ]
    },
    "prototype.caseDelayBetweenOnsetAndLabTesting": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "delays",
          "type": [
            {
              "type": {
                "dateOfOnset": "date",
                "dateSampleTaken": "date",
                "delay": {
                  "type": "number",
                  "description": "Number of days between date of onset and the date of the first lab test sample"
                },
                "case": "case"
              }
            }
          ],
          "description": "List of entries that show the delay between date of symptom onset and the lab testing for a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Get a list of entries that show the delay between date of symptom onset and the lab testing for a case",
      "http": {
        "verb": "get",
        "path": "/cases/delay-onset-lab-testing"
      }
    },
    "prototype.exportContactFollowUpListPerDay": {
      "accepts": [
        {
          "arg": "res",
          "type": "object",
          "http": {
            "source": "res"
          }
        },
        {
          "arg": "date",
          "type": "object",
          "description": "{ startDate: '2019-04-26T21:00:00.000Z', endDate: '2019-04-27T20:59:59.999Z' }"
        },
        {
          "arg": "contactId",
          "type": "string"
        },
        {
          "arg": "groupBy",
          "type": "string",
          "enum": [
            "place",
            "case"
          ]
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case', 'where.followUp' MongoDB compatible queries"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export a pdf file with the daily contact follow-up form, for every relevant contact (or case follow-ups registered as a contact), from a specific day",
      "http": {
        "verb": "get",
        "path": "/contacts/daily-followup-form/export"
      }
    },
    "prototype.restoreCaseLabResult": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for lab results"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "labResult",
          "type": "labResult",
          "description": "Lab Result",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted lab result.",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/lab-results/:fk/restore"
      }
    },
    "prototype.exportDailyContactFollowUpList": {
      "accepts": [
        {
          "arg": "res",
          "type": "object",
          "http": {
            "source": "res"
          }
        },
        {
          "arg": "groupBy",
          "type": "string"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.case', 'where.followUp' MongoDB compatible queries"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export pdf containing contacts to be seen by place/case",
      "http": {
        "verb": "get",
        "path": "/contacts/daily-list/export"
      }
    },
    "prototype.exportRangeListOfContacts": {
      "accepts": [
        {
          "arg": "data",
          "type": "object",
          "model": "exportRangeContacts",
          "description": "Group By (case, place, risk level), Range Date properties",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export pdf containing range of contacts to be seen by place/case",
      "http": {
        "verb": "post",
        "ignoreActiveOutbreak": true,
        "path": "/contacts/range-list/export"
      }
    },
    "prototype.filteredCountContactsOnFollowUpList": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "contactsCount",
          "type": "number",
          "description": "Number of contacts (that pass the filter) on the follow up list",
          "required": true
        },
        {
          "arg": "contactIDs",
          "type": [
            "string"
          ],
          "description": "Ids of contacts (that pass the filter) on the follow up list",
          "required": true
        }
      ],
      "description": "Counts the contacts that are on the follow up list, that pass a filter.",
      "http": {
        "verb": "get",
        "path": "/contacts/on-follow-up-list/count"
      }
    },
    "prototype.getContactPossibleDuplicates": {
      "accepts": [
        {
          "arg": "data",
          "type": "object",
          "model": "contact",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "duplicates",
          "type": [
            "contact"
          ],
          "description": "List of contacts that are duplicates",
          "required": true
        }
      ],
      "description": "Get list of contacts that are possible duplicates",
      "http": {
        "verb": "post",
        "path": "/contacts/duplicates/find"
      }
    },
    "prototype.getContactMarkedAsNotDuplicates": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Record primary key"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter offset and limit - must be a JSON-encoded string ({\"something\":\"value\"}).",
          "http": {
            "source": "query"
          },
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "marked-as-not-duplicates",
          "type": [
            "contact"
          ],
          "description": "List of contacts that are marked as not being duplicates",
          "root": true,
          "required": true
        }
      ],
      "description": "Get list of contacts that are possible duplicates",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/duplicates/marked-as-not-duplicates"
      }
    },
    "prototype.getContactMarkedAsNotDuplicatesCount": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Record primary key"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of of people that match the search criteria",
          "required": true
        }
      ],
      "description": "Count list of contact of contacts that are possible duplicates",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/duplicates/marked-as-not-duplicates/count"
      }
    },
    "prototype.contactMarkPersonAsOrNotADuplicate": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Record primary key"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "personDuplicateParams",
          "description": "Duplicate data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "notDuplicates",
          "type": [
            "string"
          ],
          "description": "List of not duplicates for this record",
          "root": true
        }
      ],
      "description": "Update list of records that aren't duplicates for this record",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/duplicates/change"
      }
    },
    "prototype.getCasePossibleDuplicates": {
      "accepts": [
        {
          "arg": "data",
          "type": "object",
          "model": "case",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "duplicates",
          "type": [
            "case"
          ],
          "description": "List of cases that are duplicates",
          "required": true
        }
      ],
      "description": "Get list of cases that are possible duplicates",
      "http": {
        "verb": "post",
        "path": "/cases/duplicates/find"
      }
    },
    "prototype.getCaseMarkedAsNotDuplicates": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Record primary key"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter offset and limit - must be a JSON-encoded string ({\"something\":\"value\"}).",
          "http": {
            "source": "query"
          },
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "marked-as-not-duplicates",
          "type": [
            "case"
          ],
          "description": "List of cases that are marked as not being duplicates",
          "root": true,
          "required": true
        }
      ],
      "description": "Get list of cases that are possible duplicates",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/duplicates/marked-as-not-duplicates"
      }
    },
    "prototype.getCaseMarkedAsNotDuplicatesCount": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Record primary key"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of of people that match the search criteria",
          "required": true
        }
      ],
      "description": "Count list of contact of contacts that are possible duplicates",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/duplicates/marked-as-not-duplicates/count"
      }
    },
    "prototype.caseMarkPersonAsOrNotADuplicate": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Record primary key"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "personDuplicateParams",
          "description": "Duplicate data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "notDuplicates",
          "type": [
            "string"
          ],
          "description": "List of not duplicates for this record",
          "root": true
        }
      ],
      "description": "Update list of records that aren't duplicates for this record",
      "http": {
        "verb": "post",
        "path": "/cases/:nk/duplicates/change"
      }
    },
    "prototype.caseDelayBetweenOnsetAndHospitalizationIsolation": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "delays",
          "type": [
            {
              "type": {
                "dateOfOnset": "date",
                "hospitalizationIsolationDate": "date",
                "delay": {
                  "type": "number",
                  "description": "Number of days between date of onset and the first hospitalization/isolation date of the case"
                },
                "case": "case"
              }
            }
          ],
          "description": "List of entries that show the delay between date of symptom onset and hospitalization/isolation date of a case",
          "root": true,
          "required": true
        }
      ],
      "description": "Get a list of entries that show the delay between date of symptom onset and hospitalization/isolation date of a case",
      "http": {
        "verb": "get",
        "path": "/cases/delay-onset-hospitalization"
      }
    },
    "prototype.getContactFollowUpReport": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})",
          "http": {
            "source": "query"
          },
          "required": true
        },
        {
          "arg": "body",
          "type": "object",
          "model": "dateRange",
          "description": "Start/end dates",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "report",
          "type": "object",
          "description": "Report",
          "required": true
        }
      ],
      "description": "Get total number of contacts that were followed up in the given period of time",
      "http": {
        "verb": "post",
        "ignoreActiveOutbreak": true,
        "path": "/contacts/follow-up-report"
      }
    },
    "prototype.bulkModifyContacts": {
      "accepts": [
        {
          "arg": "data",
          "type": [
            "contact"
          ],
          "description": "Array containing contacts",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "createResponse",
          "type": [
            "contact"
          ],
          "description": "Array of updated contacts",
          "root": true,
          "required": true
        }
      ],
      "description": "Update multiple contacts",
      "http": {
        "verb": "put",
        "path": "/contacts/bulk"
      }
    },
    "prototype.getFollowUpsGroupedByContact": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.contact' MongoDB compatible queries"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "data",
          "type": "object",
          "root": true,
          "description": "List of follow ups grouped by contact",
          "required": true
        }
      ],
      "description": "Get list of follow ups grouped by contact and pagination support",
      "http": {
        "verb": "get",
        "path": "/range-follow-ups"
      }
    },
    "prototype.countFollowUpsGroupedByContact": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.contact' MongoDB compatible queries"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "data",
          "type": "object",
          "root": true,
          "description": "Count groups of follow ups",
          "required": true
        }
      ],
      "description": "Count list of follow ups grouped by contact",
      "http": {
        "verb": "get",
        "path": "/range-follow-ups/count"
      }
    },
    "prototype.getCaseIsolatedContacts": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for cases"
        }
      ],
      "returns": [
        {
          "arg": "data",
          "type": "object",
          "root": true,
          "description": "Count of isolated contacts and list of ids",
          "required": true
        }
      ],
      "description": "Get count of isolated contacts for a case",
      "http": {
        "verb": "get",
        "path": "/cases/:fk/isolated-contacts"
      }
    },
    "prototype.countCasesPerPeriodPerContactStatus": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}); Note: this request also accepts 'periodType': enum [day, week, month], 'periodInterval': ['date', 'date']"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "counters",
          "type": {
            "totalCasesCount": {
              "type": "number",
              "description": "Total number of cases in the Outbreak"
            },
            "totalCasesNotFromContact": {
              "type": "number",
              "description": "Total number of cases in the Outbreak that have never been contacts"
            },
            "totalCasesFromContactWithFollowupComplete": {
              "type": "number",
              "description": "Total number of cases in the Outbreak that have been contacts and final follow-up status is Under Follow-up or Follow-up complete"
            },
            "totalCasesFromContactWithFollowupLostToFollowup": {
              "type": "number",
              "description": "Total number of cases in the Outbreak that have been contacts and final follow-up status is Lost to Follow-up"
            },
            "caseIDs": {
              "type": [
                "string"
              ],
              "description": "Array containing the cases IDs in the Outbreak"
            },
            "caseNotFromContactIDs": {
              "type": [
                "string"
              ],
              "description": "Array containing the cases IDs in the Outbreak that have never been contacts"
            },
            "caseFromContactWithFollowupCompleteIDs": {
              "type": [
                "string"
              ],
              "description": "Array containing the cases IDs in the Outbreak that have been contacts and final follow-up status is Under Follow-up or Follow-up complete"
            },
            "caseFromContactWithFollowupLostToFollowupIDs": {
              "type": [
                "string"
              ],
              "description": "Array containing the cases IDs in the Outbreak that have been contacts and final follow-up status is Lost to Follow-up"
            },
            "percentageOfCasesWithFollowupData": {
              "type": "number",
              "description": "Percentage of cases with follow-up data (final status is Under Follow-up or Follow-up complete or Lost to Follow-up)"
            },
            "period": {
              "type": [
                {
                  "type": {
                    "start": "date",
                    "end": "date",
                    "totalCasesCount": {
                      "type": "number",
                      "description": "Total number of cases in the Outbreak"
                    },
                    "totalCasesNotFromContact": {
                      "type": "number",
                      "description": "Total number of cases in the Outbreak that have never been contacts"
                    },
                    "totalCasesFromContactWithFollowupComplete": {
                      "type": "number",
                      "description": "Total number of cases in the Outbreak that have been contacts and final follow-up status is Under Follow-up or Follow-up complete"
                    },
                    "totalCasesFromContactWithFollowupLostToFollowup": {
                      "type": "number",
                      "description": "Total number of cases in the Outbreak that have been contacts and final follow-up status is Lost to Follow-up"
                    },
                    "caseIDs": {
                      "type": [
                        "string"
                      ],
                      "description": "Array containing the cases IDs in the Outbreak"
                    },
                    "caseNotFromContactIDs": {
                      "type": [
                        "string"
                      ],
                      "description": "Array containing the cases IDs in the Outbreak that have never been contacts"
                    },
                    "caseFromContactWithFollowupCompleteIDs": {
                      "type": [
                        "string"
                      ],
                      "description": "Array containing the cases IDs in the Outbreak that have been contacts and final follow-up status is Under Follow-up or Follow-up complete"
                    },
                    "caseFromContactWithFollowupLostToFollowupIDs": {
                      "type": [
                        "string"
                      ],
                      "description": "Array containing the cases IDs in the Outbreak that have been contacts and final follow-up status is Lost to Follow-up"
                    },
                    "percentageOfCasesWithFollowupData": {
                      "type": "number",
                      "description": "Percentage of cases with follow-up data (final status is Under Follow-up or Follow-up complete or Lost to Follow-up)"
                    }
                  }
                }
              ]
            }
          },
          "description": "Object containing counters for cases per period",
          "root": true,
          "required": true
        }
      ],
      "description": "Count the total number of cases per period per their contact status",
      "http": {
        "verb": "get",
        "path": "/cases/per-period-per-contact-status/count"
      }
    },
    "prototype.exportDailyContactFollowUpForm": {
      "accepts": [
        {
          "arg": "res",
          "type": "object",
          "http": {
            "source": "res"
          }
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export pdf containing daily follow up form",
      "http": {
        "verb": "get",
        "path": "/contacts/export-daily-follow-up-form"
      }
    },
    "prototype.bulkDeleteFollowUps": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "object",
          "root": true,
          "required": true
        }
      ],
      "description": "Delete a list of follow ups.",
      "http": {
        "verb": "del",
        "path": "/follow-ups/bulk"
      }
    },
    "prototype.bulkRestoreFollowUps": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "data",
          "type": "object",
          "root": true,
          "required": true
        }
      ],
      "description": "Restore a list of deleted follow ups.",
      "http": {
        "verb": "post",
        "path": "/follow-ups/bulk/restore"
      }
    },
    "prototype.restoreContactLabResult": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for lab results"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "labResult",
          "type": "labResult",
          "description": "Lab Result",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted lab result.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/lab-results/:fk/restore"
      }
    },
    "prototype.importImportableContactLabResultsFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "importLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Import a list of lab results from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/contacts/lab-results/import-importable-file-using-map"
      }
    },
    "prototype.exportFilteredLabResults": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, limit, where.useQuestionVariable, where.useDbColumns and where.dontTranslateValues - must be a JSON-encoded string ({\"something\":\"value\"}). Param 'where.useQuestionVariable' is used to display question variables as column headers. Params 'where.useDbColumns' and 'where.dontTranslateValues' are used to display db properties and values instead of label translations (useful for scripts since translation can change). A zip file will be provided in case number of records exceed file type limits (e.g. xls (biff8) has a limit of 65536 rows). Also, if number of columns exceed file limits they will be split into multiple sheets per file (e.g. xls (biff8) has a limit of 255 columns)."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "fieldsGroupList",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields groups will be included in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "exportLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Export filtered list of lab results",
      "http": {
        "verb": "get",
        "path": "/lab-results/export"
      }
    },
    "prototype.importImportableRelationshipsFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "root": true,
          "required": true
        }
      ],
      "description": "Import a list of relationships from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/relationships/import-importable-file-using-map"
      }
    },
    "prototype.findContactsOfContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.contact' MongoDB compatible query"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "data",
          "type": [
            "contactOfContact"
          ],
          "description": "List of contacts that match the search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries contacts of contacts of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/contacts-of-contacts"
        }
      ]
    },
    "prototype.filteredCountContactsOfContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: filter supports 'where.contact' MongoDB compatible query. Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of contacts that pass the filter",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts the contacts of contacts of an outbreak",
      "http": [
        {
          "verb": "get",
          "path": "/contacts-of-contacts/filtered-count"
        }
      ]
    },
    "prototype.findContactOfContactRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact of contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationships",
          "type": [
            "relationship"
          ],
          "description": "Relationships of a contact of contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationships of contact of contact.",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:nk/relationships"
      }
    },
    "prototype.createContactOfContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact of contact"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Created Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates a new instance in relationships of this model.",
      "http": {
        "verb": "post",
        "path": "/contacts-of-contacts/:nk/relationships"
      }
    },
    "prototype.getContactOfContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts of contacts"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Relationship of a contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Find a related item by id for relationships.",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:nk/relationships/:fk"
      }
    },
    "prototype.updateContactOfContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact of contact"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "data",
          "type": "object",
          "model": "relationship",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "relationship",
          "type": "relationship",
          "description": "Updated Relationship",
          "root": true,
          "required": true
        }
      ],
      "description": "Update a related item by id for relationships.",
      "http": {
        "verb": "put",
        "path": "/contacts-of-contacts/:nk/relationships/:fk"
      }
    },
    "prototype.deleteContactOfContactRelationship": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact of contact"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for relationships."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "object",
          "root": true,
          "required": true
        }
      ],
      "description": "Delete a related item by id for relationships.",
      "http": {
        "verb": "del",
        "path": "/contacts-of-contacts/:nk/relationships/:fk"
      }
    },
    "prototype.countContactOfContactRelationships": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts of contacts"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationships of a contact of contact",
          "required": true
        }
      ],
      "description": "Counts relationships of contacts of contacts.",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:nk/relationships/count"
      }
    },
    "prototype.getContactOfContactRelationshipsAvailablePeople": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts of contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"})"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "people",
          "type": [
            "person"
          ],
          "description": "List of people that match the search criteria and belong to a contact of contact. Includes matchedDuplicateRelationships for each record",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries people of a contact of contact",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:nk/relationships/available-people"
      }
    },
    "prototype.countContactOfContactRelationshipsAvailablePeople": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts of contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Supports filter.flags.applyHasMoreLimit that limits the number of counted records for a faster response."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of of people that match the search criteria and belong to a contact of contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Counts people of a contact",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:nk/relationships/available-people/count"
      }
    },
    "prototype.findContactOfContactRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts of contact"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "exposures",
          "type": [
            "exposureOrContact"
          ],
          "description": "Relationship exposures of a contact of contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries relationship exposures of a contact of contact.",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:nk/relationships/exposures"
      }
    },
    "prototype.countContactOfContactRelationshipExposures": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts of contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: the main filter applies on 'person' record while filter.where.relationship query applies on relationship"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of relationship exposures (that pass the filter) of a contact of contact",
          "required": true
        }
      ],
      "description": "Counts the relationship exposures that pass a filter of a contact of contact",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:nk/relationships/exposures/filtered-count"
      }
    },
    "prototype.exportFilteredContactsOfContacts": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, limit, where.useDbColumns and where.dontTranslateValues - must be a JSON-encoded string ({\\\"something\\\":\\\"value\\\"}). Params 'where.useDbColumns' and 'where.dontTranslateValues' are used to display db properties and values instead of label translations (useful for scripts since translation can change). A zip file will be provided in case number of records exceed file type limits (e.g. xls (biff8) has a limit of 65536 rows). Also, if number of columns exceed file limits they will be split into multiple sheets per file (e.g. xls (biff8) has a limit of 255 columns)."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "fieldsGroupList",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields groups will be included in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "exportLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Export filtered list of contacts of contacts",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/export"
      }
    },
    "prototype.importImportableContactsOfContactsFileUsingMap": {
      "accepts": [
        {
          "arg": "body",
          "type": "object",
          "model": "importableFileWithFieldAndReferenceDataMap",
          "http": {
            "source": "body"
          },
          "root": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "contacts",
          "type": [
            "contact"
          ],
          "root": true,
          "required": true
        }
      ],
      "description": "Import a list of contacts from a file that was previously uploaded as an importable file",
      "http": {
        "verb": "post",
        "path": "/contacts-of-contacts/import-importable-file-using-map"
      }
    },
    "prototype.generateContactOfContactVisualId": {
      "accepts": [
        {
          "arg": "visualIdMask",
          "type": "string",
          "required": true,
          "description": "Visual ID mask partially resolved (except for the sequence no.)"
        },
        {
          "arg": "personId",
          "type": "string",
          "description": "Contact of Contact ID for validating existing visual ID (optional)"
        }
      ],
      "returns": [
        {
          "arg": "visualId",
          "type": "string",
          "description": "Visual ID",
          "root": true,
          "required": true
        }
      ],
      "description": "Generates the next (available) visual ID based on the outbreak mask.",
      "http": {
        "verb": "post",
        "path": "/contacts-of-contacts/generate-visual-id"
      }
    },
    "prototype.getContactOfContactPossibleDuplicates": {
      "accepts": [
        {
          "arg": "data",
          "type": "object",
          "model": "contactOfContact",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "duplicates",
          "type": [
            "contactOfContact"
          ],
          "description": "List of contacts of contacts that are duplicates",
          "required": true
        }
      ],
      "description": "Get list of contacts of contacts that are possible duplicates",
      "http": {
        "verb": "post",
        "path": "/contacts-of-contacts/duplicates/find"
      }
    },
    "prototype.getContactOfContactMarkedAsNotDuplicates": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Record primary key"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter offset and limit - must be a JSON-encoded string ({\"something\":\"value\"}).",
          "http": {
            "source": "query"
          },
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "marked-as-not-duplicates",
          "type": [
            "contactOfContact"
          ],
          "description": "List of contacts that are marked as not being duplicates",
          "root": true,
          "required": true
        }
      ],
      "description": "Get list of contact of contacts that are possible duplicates",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:nk/duplicates/marked-as-not-duplicates"
      }
    },
    "prototype.getContactOfContactMarkedAsNotDuplicatesCount": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Record primary key"
        },
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": "number",
          "description": "Number of of people that match the search criteria",
          "required": true
        }
      ],
      "description": "Count list of contact of contacts that are possible duplicates",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:nk/duplicates/marked-as-not-duplicates/count"
      }
    },
    "prototype.contactOfContactMarkPersonAsOrNotADuplicate": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Record primary key"
        },
        {
          "arg": "data",
          "type": "object",
          "model": "personDuplicateParams",
          "description": "Duplicate data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "notDuplicates",
          "type": [
            "string"
          ],
          "description": "List of not duplicates for this record",
          "root": true
        }
      ],
      "description": "Update list of records that aren't duplicates for this record",
      "http": {
        "verb": "post",
        "path": "/contacts-of-contacts/:nk/duplicates/change"
      }
    },
    "prototype.restoreContactOfContact": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact of contacts"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "contactOfContact",
          "type": "contactOfContact",
          "description": "Contact Of Contact",
          "root": true,
          "required": true
        }
      ],
      "description": "Restores a deleted contact of contact.",
      "http": {
        "verb": "post",
        "path": "/contacts-of-contacts/:nk/restore"
      }
    },
    "prototype.exportFilteredCaseLabResults": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for cases"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, limit, where.useQuestionVariable, where.useDbColumns and where.dontTranslateValues - must be a JSON-encoded string ({\"something\":\"value\"}). Param 'where.useQuestionVariable' is used to display question variables as column headers. Params 'where.useDbColumns' and 'where.dontTranslateValues' are used to display db properties and values instead of label translations (useful for scripts since translation can change). A zip file will be provided in case number of records exceed file type limits (e.g. xls (biff8) has a limit of 65536 rows). Also, if number of columns exceed file limits they will be split into multiple sheets per file (e.g. xls (biff8) has a limit of 255 columns)."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "fieldsGroupList",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields groups will be included in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "exportLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Export filtered list of lab results",
      "http": {
        "verb": "get",
        "path": "/cases/:nk/lab-results/export"
      }
    },
    "prototype.exportFilteredContactLabResults": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, limit, where.useQuestionVariable, where.useDbColumns and where.dontTranslateValues - must be a JSON-encoded string ({\"something\":\"value\"}). Param 'where.useQuestionVariable' is used to display question variables as column headers. Params 'where.useDbColumns' and 'where.dontTranslateValues' are used to display db properties and values instead of label translations (useful for scripts since translation can change). A zip file will be provided in case number of records exceed file type limits (e.g. xls (biff8) has a limit of 65536 rows). Also, if number of columns exceed file limits they will be split into multiple sheets per file (e.g. xls (biff8) has a limit of 255 columns)."
        },
        {
          "arg": "type",
          "type": "string",
          "enum": [
            "json",
            "csv",
            "xls",
            "xlsx",
            "ods",
            "pdf"
          ],
          "description": "Export type; can be: json, csv, xls, xlsx, ods, pdf or csv. Default: json"
        },
        {
          "arg": "encryptPassword",
          "type": "string",
          "description": "If provided, the exported file will be encrypted using aes-256-ctr algorithm using the provided password"
        },
        {
          "arg": "anonymizeFields",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields will be anonymized in the exported file"
        },
        {
          "arg": "fieldsGroupList",
          "type": [
            "string"
          ],
          "description": "If provided, mentioned fields groups will be included in the exported file"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "exportLogId",
          "type": "string",
          "required": true
        }
      ],
      "description": "Export filtered list of lab results",
      "http": {
        "verb": "get",
        "path": "/contacts/:nk/lab-results/export"
      }
    },
    "prototype.contactOfContactDossier": {
      "accepts": [
        {
          "arg": "contactsOfContacts",
          "type": [
            "string"
          ],
          "description": "Array of contacts for which the dossiers will be generated"
        },
        {
          "arg": "data",
          "type": [
            "string"
          ],
          "description": "Array of fields to be anonymized"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "body",
          "type": "file",
          "root": true,
          "required": true
        },
        {
          "arg": "Content-Type",
          "type": "string",
          "http": {
            "target": "header"
          }
        },
        {
          "arg": "Content-Disposition",
          "type": "string",
          "http": {
            "target": "header"
          }
        }
      ],
      "description": "Export dossier for one or more contacts",
      "http": {
        "verb": "post",
        "ignoreActiveOutbreak": true,
        "path": "/contacts-of-contacts/dossier"
      }
    },
    "prototype.getContactOfContactMovement": {
      "accepts": [
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for contacts of contacts"
        }
      ],
      "returns": [
        {
          "arg": "movement",
          "type": [
            "address"
          ],
          "description": "List of addresses with GeoLocations ordered from the oldest one to the most recent",
          "root": true,
          "required": true
        }
      ],
      "description": "Get list of addresses with GeoLocations ordered from the oldest one to the most recent",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/:fk/movement"
      }
    },
    "prototype.countContactsOfContactsPerRiskLevel": {
      "accepts": [
        {
          "arg": "filter",
          "type": "object",
          "description": "Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({\"something\":\"value\"}). Note: it supports same filters as GET /outbreak/:id/contacts"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "count",
          "type": {
            "riskLevel": {
              "type": {
                "<riskLevel>": {
                  "type": {
                    "count": "number"
                  }
                }
              }
            },
            "count": "number"
          },
          "description": "Number of contacts of contacts grouped by risk level",
          "required": true,
          "root": true
        }
      ],
      "description": "Counts the number of contacts grouped by risk level",
      "http": {
        "verb": "get",
        "path": "/contacts-of-contacts/per-risk-level/count"
      }
    },
    "prototype.bulkModifyContactsOfContacts": {
      "accepts": [
        {
          "arg": "data",
          "type": [
            "contactOfContact"
          ],
          "description": "Array containing contacts of contacts",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        }
      ],
      "returns": [
        {
          "arg": "createResponse",
          "type": [
            "contact"
          ],
          "description": "Array of updated contacts of contacts",
          "root": true,
          "required": true
        }
      ],
      "description": "Update multiple contacts of contacts",
      "http": {
        "verb": "put",
        "path": "/contacts-of-contacts/bulk"
      }
    },
    "prototype.createContactMultipleContactsOfContacts": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contacts"
        },
        {
          "arg": "data",
          "type": [
            "contactOfContactAndRelationship"
          ],
          "description": "Array containing pairs for contact of contact + relationship",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "createResponse",
          "type": [
            "contactOfContactAndRelationship"
          ],
          "description": "Array of responses for the create actions",
          "root": true,
          "required": true
        }
      ],
      "description": "Creates multiple contacts of contacts for a contact.",
      "http": {
        "verb": "post",
        "path": "/contacts/:nk/contacts-of-contacts"
      }
    },
    "prototype.modifyContactFollowUp": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for follow-ups."
        },
        {
          "arg": "data",
          "type": "object",
          "model": "followUp",
          "description": "Model instance data",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "followUp",
          "type": "followUp",
          "description": "Updated Followup",
          "root": true,
          "required": true
        }
      ],
      "description": "Update a contact's follow-up.",
      "http": {
        "verb": "put",
        "path": "/contacts/:nk/follow-ups/:fk"
      }
    },
    "prototype.deleteContactFollowUp": {
      "accepts": [
        {
          "arg": "nk",
          "type": "string",
          "description": "Foreign key for contact"
        },
        {
          "arg": "fk",
          "type": "string",
          "description": "Foreign key for follow-ups."
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "description": "Delete a contact's follow-up.",
      "http": {
        "verb": "del",
        "path": "/contacts/:nk/follow-ups/:fk"
      }
    },
    "prototype.bulkModifyFollowUps": {
      "accepts": [
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances",
          "http": {
            "source": "query"
          },
          "required": true
        },
        {
          "arg": "data",
          "type": "object",
          "model": "followUp",
          "description": "Follow-up properties",
          "http": {
            "source": "body"
          },
          "root": true,
          "required": true
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "response",
          "type": {
            "count": {
              "type": "number"
            }
          },
          "description": "Number of updated follow ups",
          "root": true,
          "required": true
        }
      ],
      "description": "Bulk update follow-ups",
      "http": {
        "verb": "put",
        "path": "/follow-ups/bulk"
      }
    },
    "prototype.getCaseCountMap": {
      "accepts": [
        {
          "arg": "where",
          "type": "object",
          "description": "Criteria to match model instances"
        },
        {
          "arg": "options",
          "type": "object",
          "http": "optionsFromRequest"
        }
      ],
      "returns": [
        {
          "arg": "geoPoints",
          "type": [
            "customGeoPoint"
          ],
          "description": "List of case main addresses geo points that have geo location and match search criteria",
          "root": true,
          "required": true
        }
      ],
      "description": "Queries cases of outbreak.",
      "http": [
        {
          "verb": "get",
          "path": "/cases/count-map"
        }
      ]
    },
    "exportFieldsGroup": {
      "accepts": [
        {
          "arg": "model",
          "type": "string"
        }
      ],
      "returns": [
        {
          "arg": "result",
          "type": {
            "<groupId>": {
              "properties": [],
              "required": []
            }
          },
          "root": true,
          "required": true
        }
      ],
      "description": "Retrieves the export fields groups",
      "http": {
        "verb": "get",
        "path": "/export-fields-group"
      }
    }
  }
}
